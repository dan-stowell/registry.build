<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">RapidCheck <a href="https://travis-ci.org/emil-e/rapidcheck" rel="nofollow"><img src="https://camo.githubusercontent.com/138669422c0b05ddacea85e5fbe801f173d875cfdb9034fa9a9ea656c8cb300b/68747470733a2f2f7472617669732d63692e6f72672f656d696c2d652f7261706964636865636b2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/emil-e/rapidcheck.svg?branch=master" style="max-width: 100%;"></a> <a href="https://ci.appveyor.com/project/emil-e/rapidcheck/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/2259e56bde92a82e23ae68fb04b1a8e5f6cafd9a2a826fee36cb5ed453aa3de5/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f38686d73353667686e3237616770636a2f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/8hms56ghn27agpcj/branch/master?svg=true" style="max-width: 100%;"></a></h1><a id="user-content-rapidcheck--" class="anchor" aria-label="Permalink: RapidCheck " href="#rapidcheck--"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RapidCheck is a C++ framework for property based testing inspired by QuickCheck and other similar frameworks. In property based testing, you state facts about your code that given certain precondition should always be true. RapidCheck then generates random test data to try and find a case for which the property doesn't hold. If such a case is found, RapidCheck tries to find the smallest case (for some definition of smallest) for which the property is still false and then displays this as a counterexample. For example, if the input is an integer, RapidCheck tries to find the smallest integer for which the property is false.</p>
<p dir="auto">Sounds interesting? Why don't you read the <strong><a href="doc/user_guide.md">User Guide</a></strong> to learn more!</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Why RapidCheck?</h2><a id="user-content-why-rapidcheck" class="anchor" aria-label="Permalink: Why RapidCheck?" href="#why-rapidcheck"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There are existing implementations of property based testing but the ones that I have found are either (in my humble opinion) a bit clunky or are missing essential features such as test case shrinking.</p>
<p dir="auto">Let's throw together a list of features:</p>
<ul dir="auto">
<li>Write your properties in an imperative way that makes sense for C++</li>
<li>Test case shrinking</li>
<li>Great support for STL types, including maps and sets</li>
<li>Advanced combinators for creating your own generators</li>
<li>Stateful based on commands in the vein of Erlang QuickCheck</li>
<li>Integration with popular testing frameworks such as Boost Test, Google Test and Google Mock</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Prerequisites and installation</h2><a id="user-content-prerequisites-and-installation" class="anchor" aria-label="Permalink: Prerequisites and installation" href="#prerequisites-and-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RapidCheck makes extensive use of C++11 and thus requires a compliant compiler. RapidCheck continuous integration builds using Clang 3.5, GCC 4.9 and Visual Studio 2015 so any later versions should also work.</p>
<p dir="auto">RapidCheck uses CMake and is built like any other CMake project. If your own project uses CMake you can simply have RapidCheck as a subdirectory and add the following to your <code>CMakeLists.txt</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add_subdirectory(&quot;path/to/rapidcheck&quot;)
target_link_libraries(my_target rapidcheck)"><pre class="notranslate"><code>add_subdirectory("path/to/rapidcheck")
target_link_libraries(my_target rapidcheck)
</code></pre></div>
<p dir="auto">This will give you both linking and include directories.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Quick introduction</h2><a id="user-content-quick-introduction" class="anchor" aria-label="Permalink: Quick introduction" href="#quick-introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A common first example is testing a reversal function. For such a function, double reversal should always result in the original list. In this example we will use the standard C++ <code>std::reverse</code> function:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;rapidcheck.h&gt;

#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  rc::check(&quot;double reversal yields the original value&quot;,
            [](const std::vector&lt;int&gt; &amp;l0) {
              auto l1 = l0;
              std::reverse(begin(l1), end(l1));
              std::reverse(begin(l1), end(l1));
              RC_ASSERT(l0 == l1);
            });

  return 0;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>rapidcheck.h<span class="pl-pds">&gt;</span></span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  <span class="pl-c1">rc::check</span>(<span class="pl-s"><span class="pl-pds">"</span>double reversal yields the original value<span class="pl-pds">"</span></span>,
            [](<span class="pl-k">const</span> std::vector&lt;<span class="pl-k">int</span>&gt; &amp;l0) {
              <span class="pl-k">auto</span> l1 = l0;
              <span class="pl-c1">std::reverse</span>(<span class="pl-c1">begin</span>(l1), <span class="pl-c1">end</span>(l1));
              <span class="pl-c1">std::reverse</span>(<span class="pl-c1">begin</span>(l1), <span class="pl-c1">end</span>(l1));
              <span class="pl-c1">RC_ASSERT</span>(l0 == l1);
            });

  <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p dir="auto">The <code>check</code> function is used to check properties. The first parameter is an optional string which describes the property. The second parameter is a callable object that implements the property, in this case a lambda. Any parameters to the callable (in our case the <code>l0</code> parameter) will be randomly generated. The <code>RC_ASSERT</code> macro works just like any other assert macro. If the given condition is false, the property has been falsified.</p>
<p dir="auto">The property above also forms part of a specification of the reversal function: "For any list of integers A, reversing and then reversing again should result in A".</p>
<p dir="auto">If we were to run this, RapidCheck would (hopefully) output the following:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Using configuration: seed=9928307433081493900

- double reversal yields the original value
OK, passed 100 tests"><pre lang="text" class="notranslate"><code>Using configuration: seed=9928307433081493900

- double reversal yields the original value
OK, passed 100 tests
</code></pre></div>
<p dir="auto">Here, RapidCheck tells us that it ran 100 test cases and all of them passed. It also tells us the configuration that was used, in particular the random seed. If there was a bug in the implementation of <code>std::reverse</code> we could get the following output instead:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Falsifiable after 12 tests and 10 shrinks

std::tuple&lt;std::vector&lt;int&gt;&gt;:
([1, 0, 0, 0, 0, 0, 0, 0, 0, 0])

main.cpp:17:
RC_ASSERT(l0 == l1)

Expands to:
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"><pre lang="text" class="notranslate"><code>Falsifiable after 12 tests and 10 shrinks

std::tuple&lt;std::vector&lt;int&gt;&gt;:
([1, 0, 0, 0, 0, 0, 0, 0, 0, 0])

main.cpp:17:
RC_ASSERT(l0 == l1)

Expands to:
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre></div>
<p dir="auto">Here RapidCheck tells us that it found a case for which the property does not hold after running 12 tests. When it found this case, it shrunk it 10 times to arrive at the counterexample in the output. The counterexample contains each input value that was used for the failing case along with its type. Since RapidCheck views property arguments as tuples, the type is shown here as <code>std::tuple&lt;std::vector&lt;int&gt;&gt;</code>.</p>
<p dir="auto">Can you guess what the bug is? The fact that there are exactly 10 items should give a clue. In this case, the bug is that the implementation sets the first element to <code>0</code> when <code>l0.size() &gt;= 10</code>. This is also the reason for the initial <code>0</code>, the problem doesn't manifest when all elements are zero. How did this bug happen? Who knows!</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Thanks</h2><a id="user-content-thanks" class="anchor" aria-label="Permalink: Thanks" href="#thanks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Big thanks to my employer, Spotify, for making it possible for me to spend work time improving RapidCheck.</p>
</article></div>