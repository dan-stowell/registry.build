<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">FCL -- The Flexible Collision Library</h2><a id="user-content-fcl----the-flexible-collision-library" class="anchor" aria-label="Permalink: FCL -- The Flexible Collision Library" href="#fcl----the-flexible-collision-library"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Linux / OS X <a href="https://travis-ci.org/flexible-collision-library/fcl" rel="nofollow"><img src="https://camo.githubusercontent.com/43561a63c762eafdbb173e6f07bdc51cedc915a06b600d93af56e77a4338801c/68747470733a2f2f7472617669732d63692e6f72672f666c657869626c652d636f6c6c6973696f6e2d6c6962726172792f66636c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/flexible-collision-library/fcl.svg?branch=master" style="max-width: 100%; height: auto;"></a>
Windows <a href="https://ci.appveyor.com/project/flexible-collision-library/fcl" rel="nofollow"><img src="https://camo.githubusercontent.com/0058bd991ba83d45cec26d93860043a35a7e74aed76b5dfddeb5513958b99af9/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f646f316b373237757536653875656d662f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/do1k727uu6e8uemf/branch/master?svg=true" style="max-width: 100%; height: auto;"></a>
Coverage <a href="https://coveralls.io/github/flexible-collision-library/fcl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/650179507ae9b11c04446af86af3dceded46d463b6dd071a8f5e2a298b377922/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f666c657869626c652d636f6c6c6973696f6e2d6c6962726172792f66636c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/flexible-collision-library/fcl/badge.svg?branch=master" style="max-width: 100%; height: auto;"></a></p>
<p dir="auto">FCL is a library for performing three types of proximity queries on a pair of
geometric models composed of triangles.</p>
<ul dir="auto">
<li>Collision detection: detecting whether the two models overlap, and
optionally, all of the triangles that overlap.</li>
<li>Distance computation: computing the minimum distance between a pair of
models, i.e., the distance between the closest pair of points.</li>
<li>Tolerance verification: determining whether two models are closer or farther
than a tolerance distance.</li>
<li>Continuous collision detection: detecting whether the two moving models
overlap during the movement, and optionally, the time of contact.</li>
<li>Contact information: for collision detection and continuous collision
detection, the contact information (including contact normals and contact
points) can be returned optionally.</li>
</ul>
<p dir="auto">FCL has the following features</p>
<ul dir="auto">
<li>C++ interface</li>
<li>Compilable for either linux or win32 (both makefiles and Microsoft Visual
projects can be generated using cmake)</li>
<li>No special topological constraints or adjacency information required for
input models â€“ all that is necessary is a list of the model's triangles</li>
<li>Supported different object shapes:</li>
</ul>
<ul dir="auto">
<li>box</li>
<li>sphere</li>
<li>ellipsoid</li>
<li>capsule</li>
<li>cone</li>
<li>cylinder</li>
<li>convex</li>
<li>half-space</li>
<li>plane</li>
<li>mesh</li>
<li>octree (optional, octrees are represented using the octomap library
<a href="http://octomap.github.com">http://octomap.github.com</a>)</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Installation</h2><a id="user-content-installation" class="anchor" aria-label="Permalink: Installation" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Before compiling FCL, please make sure Eigen and libccd (for collision checking
between convex objects and is available here <a href="https://github.com/danfis/libccd">https://github.com/danfis/libccd</a>)
are installed. For libccd, make sure to compile from github version instead of
the zip file from the webpage, because one bug fixing is not included in the
zipped version.</p>
<p dir="auto">Some optional libraries need to be installed for some optional capability of
FCL. For octree collision, please install the octomap library from
<a href="https://octomap.github.io/" rel="nofollow">https://octomap.github.io/</a>.</p>
<p dir="auto">CMakeLists.txt is used to generate makefiles in Linux or Visual studio projects
in windows. In command line, run</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mkdir build
cd build
cmake .."><pre><span class="pl-s">mkdir</span> <span class="pl-c1">build</span>
<span class="pl-s">cd</span> <span class="pl-c1">build</span>
<span class="pl-s">cmake</span> <span class="pl-s">..</span></pre></div>
<p dir="auto">Next, in linux, use make to compile the code.</p>
<p dir="auto">In windows, there will generate a visual studio project and then you can compile
the code.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Interfaces</h2><a id="user-content-interfaces" class="anchor" aria-label="Permalink: Interfaces" href="#interfaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Before starting the proximity computation, we need first to set the geometry and
transform for the objects involving in computation. The geometry of an object is
represented as a mesh soup, which can be set as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// set mesh triangles and vertice indices
std::vector&lt;Vector3f&gt; vertices;
std::vector&lt;Triangle&gt; triangles;
// code to set the vertices and triangles
...
// BVHModel is a template class for mesh geometry, for default OBBRSS template
// is used
typedef BVHModel&lt;OBBRSSf&gt; Model;
std::shared_ptr&lt;Model&gt; geom = std::make_shared&lt;Model&gt;();
// add the mesh data into the BVHModel structure
geom-&gt;beginModel();
geom-&gt;addSubModel(vertices, triangles);
geom-&gt;endModel();"><pre><span class="pl-c"><span class="pl-c">//</span> set mesh triangles and vertice indices</span>
std::vector&lt;Vector3f&gt; vertices;
std::vector&lt;Triangle&gt; triangles;
<span class="pl-c"><span class="pl-c">//</span> code to set the vertices and triangles</span>
...
<span class="pl-c"><span class="pl-c">//</span> BVHModel is a template class for mesh geometry, for default OBBRSS template</span>
<span class="pl-c"><span class="pl-c">//</span> is used</span>
<span class="pl-k">typedef</span> BVHModel&lt;OBBRSSf&gt; Model;
std::shared_ptr&lt;Model&gt; geom = std::make_shared&lt;Model&gt;();
<span class="pl-c"><span class="pl-c">//</span> add the mesh data into the BVHModel structure</span>
geom-&gt;<span class="pl-en">beginModel</span>();
geom-&gt;<span class="pl-en">addSubModel</span>(vertices, triangles);
geom-&gt;<span class="pl-en">endModel</span>();</pre></div>
<p dir="auto">The transform of an object includes the rotation and translation:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// R and T are the rotation matrix and translation vector
Matrix3f R;
Vector3f T;
// code for setting R and T
...
// transform is configured according to R and T
Transform3f pose = Transform3f::Identity();
pose.linear() = R;
pose.translation() = T;"><pre><span class="pl-c"><span class="pl-c">//</span> R and T are the rotation matrix and translation vector</span>
Matrix3f R;
Vector3f T;
<span class="pl-c"><span class="pl-c">//</span> code for setting R and T</span>
...
<span class="pl-c"><span class="pl-c">//</span> transform is configured according to R and T</span>
Transform3f pose = Transform3f::Identity();
pose.linear() = R;
pose.translation() = T;</pre></div>
<p dir="auto">Given the geometry and the transform, we can also combine them together to
obtain a collision object instance and here is an example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="//geom and tf are the geometry and the transform of the object
std::shared_ptr&lt;BVHModel&lt;OBBRSSf&gt;&gt; geom = ...
Transform3f tf = ...
//Combine them together
CollisionObjectf* obj = new CollisionObjectf(geom, tf);"><pre><span class="pl-c"><span class="pl-c">//</span>geom and tf are the geometry and the transform of the object</span>
std::shared_ptr&lt;BVHModel&lt;OBBRSSf&gt;&gt; geom = ...
Transform3f tf = ...
<span class="pl-c"><span class="pl-c">//</span>Combine them together</span>
CollisionObjectf* obj = <span class="pl-k">new</span> CollisionObjectf(geom, tf);</pre></div>
<p dir="auto">Once the objects are set, we can perform the proximity computation between them.
All the proximity queries in FCL follow a common pipeline: first, set the query
request data structure and then run the query function by using request as the
input. The result is returned in a query result data structure. For example, for
collision checking, we first set the CollisionRequest data structure, and then
run the collision function:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// Given two objects o1 and o2
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
// set the collision request structure, here we just use the default setting
CollisionRequest request;
// result will be returned via the collision result structure
CollisionResult result;
// perform collision test
collide(o1, o2, request, result);"><pre><span class="pl-c"><span class="pl-c">//</span> Given two objects o1 and o2</span>
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
<span class="pl-c"><span class="pl-c">//</span> set the collision request structure, here we just use the default setting</span>
CollisionRequest request;
<span class="pl-c"><span class="pl-c">//</span> result will be returned via the collision result structure</span>
CollisionResult result;
<span class="pl-c"><span class="pl-c">//</span> perform collision test</span>
<span class="pl-en">collide</span>(o1, o2, request, result);</pre></div>
<p dir="auto">By setting the collision request, the user can easily choose whether to return
contact information (which is slower) or just return binary collision results
(which is faster).</p>
<p dir="auto">For distance computation, the pipeline is almost the same:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// Given two objects o1 and o2
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
// set the distance request structure, here we just use the default setting
DistanceRequest request;
// result will be returned via the collision result structure
DistanceResult result;
// perform distance test
distance(o1, o2, request, result);"><pre><span class="pl-c"><span class="pl-c">//</span> Given two objects o1 and o2</span>
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
<span class="pl-c"><span class="pl-c">//</span> set the distance request structure, here we just use the default setting</span>
DistanceRequest request;
<span class="pl-c"><span class="pl-c">//</span> result will be returned via the collision result structure</span>
DistanceResult result;
<span class="pl-c"><span class="pl-c">//</span> perform distance test</span>
<span class="pl-en">distance</span>(o1, o2, request, result);</pre></div>
<p dir="auto">For continuous collision, FCL requires the goal transform to be provided (the
initial transform is included in the collision object data structure). Beside
that, the pipeline is almost the same as distance/collision:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// Given two objects o1 and o2
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
// The goal transforms for o1 and o2
Transform3f tf_goal_o1 = ...
Transform3f tf_goal_o2 = ...
// set the continuous collision request structure, here we just use the default
// setting
ContinuousCollisionRequest request;
// result will be returned via the continuous collision result structure
ContinuousCollisionResult result;
// perform continuous collision test
continuousCollide(o1, tf_goal_o1, o2, tf_goal_o2, request, result);"><pre><span class="pl-c"><span class="pl-c">//</span> Given two objects o1 and o2</span>
CollisionObjectf* o1 = ...
CollisionObjectf* o2 = ...
<span class="pl-c"><span class="pl-c">//</span> The goal transforms for o1 and o2</span>
Transform3f tf_goal_o1 = ...
Transform3f tf_goal_o2 = ...
<span class="pl-c"><span class="pl-c">//</span> set the continuous collision request structure, here we just use the default</span>
<span class="pl-c"><span class="pl-c">//</span> setting</span>
ContinuousCollisionRequest request;
<span class="pl-c"><span class="pl-c">//</span> result will be returned via the continuous collision result structure</span>
ContinuousCollisionResult result;
<span class="pl-c"><span class="pl-c">//</span> perform continuous collision test</span>
<span class="pl-en">continuousCollide</span>(o1, tf_goal_o1, o2, tf_goal_o2, request, result);</pre></div>
<p dir="auto">FCL supports broadphase collision/distance between two groups of objects and can
avoid the n square complexity. For collision, broadphase algorithm can return
all the collision pairs. For distance, it can return the pair with the minimum
distance. FCL uses a CollisionManager structure to manage all the objects
involving the collision or distance operations.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// Initialize the collision manager for the first group of objects. 
// FCL provides various different implementations of CollisionManager.
// Generally, the DynamicAABBTreeCollisionManager would provide the best
// performance.
BroadPhaseCollisionManagerf* manager1 = new DynamicAABBTreeCollisionManagerf(); 
// Initialize the collision manager for the second group of objects.
BroadPhaseCollisionManagerf* manager2 = new DynamicAABBTreeCollisionManagerf();
// To add objects into the collision manager, using
// BroadPhaseCollisionManager::registerObject() function to add one object
std::vector&lt;CollisionObjectf*&gt; objects1 = ...
for(std::size_t i = 0; i &lt; objects1.size(); ++i)
manager1-&gt;registerObject(objects1[i]);
// Another choose is to use BroadPhaseCollisionManager::registerObjects()
// function to add a set of objects
std::vector&lt;CollisionObjectf*&gt; objects2 = ...
manager2-&gt;registerObjects(objects2);
// In order to collect the information during broadphase, CollisionManager
// requires two settings:
// a) a callback to collision or distance; 
// b) an intermediate data to store the information generated during the
//    broadphase computation.
// For convenience, FCL provides default callbacks to satisfy a) and a
// corresponding call back data to satisfy b) for both collision and distance
// queries. For collision use DefaultCollisionCallback and DefaultCollisionData
// and for distance use DefaultDistanceCallback and DefaultDistanceData.
// The default collision/distance data structs are simply containers which
// include the request and distance structures for each query type as mentioned
// above.
DefaultCollisionData collision_data;
DefaultDistanceData distance_data;
// Setup the managers, which is related with initializing the broadphase
// acceleration structure according to objects input
manager1-&gt;setup();
manager2-&gt;setup();
// Examples for various queries
// 1. Collision query between two object groups and get collision numbers
manager2-&gt;collide(manager1, &amp;collision_data, DefaultCollisionFunction);
int n_contact_num = collision_data.result.numContacts(); 
// 2. Distance query between two object groups and get the minimum distance
manager2-&gt;distance(manager1, &amp;distance_data, DefaultDistanceFunction);
double min_distance = distance_data.result.min_distance;
// 3. Self collision query for group 1
manager1-&gt;collide(&amp;collision_data, DefaultCollisionFunction);
// 4. Self distance query for group 1
manager1-&gt;distance(&amp;distance_data, DefaultDistanceFunction);
// 5. Collision query between one object in group 1 and the entire group 2
manager2-&gt;collide(objects1[0], &amp;collision_data, DefaultCollisionFunction);
// 6. Distance query between one object in group 1 and the entire group 2
manager2-&gt;distance(objects1[0], &amp;distance_data, DefaultDistanceFunction);"><pre><span class="pl-c"><span class="pl-c">//</span> Initialize the collision manager for the first group of objects. </span>
<span class="pl-c"><span class="pl-c">//</span> FCL provides various different implementations of CollisionManager.</span>
<span class="pl-c"><span class="pl-c">//</span> Generally, the DynamicAABBTreeCollisionManager would provide the best</span>
<span class="pl-c"><span class="pl-c">//</span> performance.</span>
BroadPhaseCollisionManagerf* manager1 = <span class="pl-k">new</span> DynamicAABBTreeCollisionManagerf(); 
<span class="pl-c"><span class="pl-c">//</span> Initialize the collision manager for the second group of objects.</span>
BroadPhaseCollisionManagerf* manager2 = <span class="pl-k">new</span> DynamicAABBTreeCollisionManagerf();
<span class="pl-c"><span class="pl-c">//</span> To add objects into the collision manager, using</span>
<span class="pl-c"><span class="pl-c">//</span> BroadPhaseCollisionManager::registerObject() function to add one object</span>
std::vector&lt;CollisionObjectf*&gt; objects1 = ...
<span class="pl-k">for</span>(std::<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; objects1.size(); ++i)
manager1-&gt;<span class="pl-en">registerObject</span>(objects1[i]);
<span class="pl-c"><span class="pl-c">//</span> Another choose is to use BroadPhaseCollisionManager::registerObjects()</span>
<span class="pl-c"><span class="pl-c">//</span> function to add a set of objects</span>
std::vector&lt;CollisionObjectf*&gt; objects2 = ...
manager2-&gt;<span class="pl-en">registerObjects</span>(objects2);
<span class="pl-c"><span class="pl-c">//</span> In order to collect the information during broadphase, CollisionManager</span>
<span class="pl-c"><span class="pl-c">//</span> requires two settings:</span>
<span class="pl-c"><span class="pl-c">//</span> a) a callback to collision or distance; </span>
<span class="pl-c"><span class="pl-c">//</span> b) an intermediate data to store the information generated during the</span>
<span class="pl-c"><span class="pl-c">//</span>    broadphase computation.</span>
<span class="pl-c"><span class="pl-c">//</span> For convenience, FCL provides default callbacks to satisfy a) and a</span>
<span class="pl-c"><span class="pl-c">//</span> corresponding call back data to satisfy b) for both collision and distance</span>
<span class="pl-c"><span class="pl-c">//</span> queries. For collision use DefaultCollisionCallback and DefaultCollisionData</span>
<span class="pl-c"><span class="pl-c">//</span> and for distance use DefaultDistanceCallback and DefaultDistanceData.</span>
<span class="pl-c"><span class="pl-c">//</span> The default collision/distance data structs are simply containers which</span>
<span class="pl-c"><span class="pl-c">//</span> include the request and distance structures for each query type as mentioned</span>
<span class="pl-c"><span class="pl-c">//</span> above.</span>
DefaultCollisionData collision_data;
DefaultDistanceData distance_data;
<span class="pl-c"><span class="pl-c">//</span> Setup the managers, which is related with initializing the broadphase</span>
<span class="pl-c"><span class="pl-c">//</span> acceleration structure according to objects input</span>
manager1-&gt;<span class="pl-en">setup</span>();
manager2-&gt;<span class="pl-en">setup</span>();
<span class="pl-c"><span class="pl-c">//</span> Examples for various queries</span>
<span class="pl-c"><span class="pl-c">//</span> 1. Collision query between two object groups and get collision numbers</span>
manager2-&gt;<span class="pl-en">collide</span>(manager1, &amp;collision_data, DefaultCollisionFunction);
<span class="pl-k">int</span> n_contact_num = collision_data.result.numContacts(); 
<span class="pl-c"><span class="pl-c">//</span> 2. Distance query between two object groups and get the minimum distance</span>
manager2-&gt;<span class="pl-en">distance</span>(manager1, &amp;distance_data, DefaultDistanceFunction);
<span class="pl-k">double</span> min_distance = distance_data.result.min_distance;
<span class="pl-c"><span class="pl-c">//</span> 3. Self collision query for group 1</span>
manager1-&gt;<span class="pl-en">collide</span>(&amp;collision_data, DefaultCollisionFunction);
<span class="pl-c"><span class="pl-c">//</span> 4. Self distance query for group 1</span>
manager1-&gt;<span class="pl-en">distance</span>(&amp;distance_data, DefaultDistanceFunction);
<span class="pl-c"><span class="pl-c">//</span> 5. Collision query between one object in group 1 and the entire group 2</span>
manager2-&gt;<span class="pl-en">collide</span>(objects1[<span class="pl-c1">0</span>], &amp;collision_data, DefaultCollisionFunction);
<span class="pl-c"><span class="pl-c">//</span> 6. Distance query between one object in group 1 and the entire group 2</span>
manager2-&gt;<span class="pl-en">distance</span>(objects1[<span class="pl-c1">0</span>], &amp;distance_data, DefaultDistanceFunction);</pre></div>
<p dir="auto">For more examples, please refer to the test folder:</p>
<ul dir="auto">
<li>test_fcl_collision.cpp: provide examples for collision test</li>
<li>test_fcl_distance.cpp: provide examples for distance test</li>
<li>test_fcl_broadphase.cpp: provide examples for broadphase collision/distance
test</li>
<li>test_fcl_frontlist.cpp: provide examples for frontlist collision acceleration</li>
<li>test_fcl_octomap.cpp: provide examples for collision/distance computation
between octomap data and other data types.</li>
</ul>
</article></div>