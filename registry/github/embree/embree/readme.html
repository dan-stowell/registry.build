<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">% Embree: High Performance Ray Tracing Kernels 4.4.0
% Intel Corporation</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Intel® Embree Overview</h1><a id="user-content-intel-embree-overview" class="anchor" aria-label="Permalink: Intel® Embree Overview" href="#intel-embree-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Intel® Embree is a high-performance ray tracing library developed at
Intel, which is released as open source under the <a href="http://www.apache.org/licenses/LICENSE-2.0" rel="nofollow">Apache 2.0
license</a>. Intel® Embree
supports x86 CPUs under Linux, macOS, and Windows; ARM CPUs on Linux
and macOS; as well as Intel® GPUs under Linux and Windows.</p>
<p dir="auto">Intel® Embree targets graphics application developers to improve the
performance of photo-realistic rendering applications. Embree is
optimized towards production rendering, by putting focus on incoherent
ray performance, high quality acceleration structure construction, a
rich feature set, accurate primitive intersection, and low memory
consumption.</p>
<p dir="auto">Embree's feature set includes various primitive types such as
triangles (as well quad and grids for lower memory consumption);
Catmull-Clark subdivision surfaces; various types of curve primitives,
such as flat curves (for distant views), round curves (for closeup
views), and normal oriented curves, all supported with different basis
functions (linear, Bézier, B-spline, Hermite, and Catmull Rom);
point-like primitives, such as ray oriented discs, normal oriented
discs, and spheres; user defined geometries with a procedural
intersection function; multi-level instancing; filter callbacks
invoked for any hit encountered; motion blur including multi-segment
motion blur, deformation blur, and quaternion motion blur; and ray
masking.</p>
<p dir="auto">Intel® Embree contains ray tracing kernels optimized for the latest
x86 processors with support for SSE, AVX, AVX2, and AVX-512
instructions, and uses runtime code selection to choose between these
kernels. Intel® Embree contains algorithms optimized for incoherent
workloads (e.g.  Monte Carlo ray tracing algorithms) and coherent
workloads (e.g. primary visibility and hard shadow rays) as well as
supports for dynamic scenes by implementing high-performance two-level
spatial index structure construction algorithms.</p>
<p dir="auto">Intel® Embree supports applications written with the Intel® Implicit
SPMD Program Compiler (Intel® ISPC, <a href="https://ispc.github.io/" rel="nofollow">https://ispc.github.io/</a>) by
providing an ISPC interface to the core ray tracing
algorithms. This makes it possible to write a renderer that
automatically vectorizes and leverages SSE, AVX, AVX2, and AVX-512
instructions.</p>
<p dir="auto">Intel® Embree supports Intel GPUs through the
<a href="https://www.khronos.org/sycl/" rel="nofollow">SYCL</a> open standard programming
language. SYCL allows to write C++ code that can be run on various
devices, such as CPUs and GPUs. Using Intel® Embree application
developers can write a single source renderer that executes
efficiently on CPUs and GPUs. Maintaining just one code base
this way can significantly improve productivity and eliminate
inconsistencies between a CPU and GPU version of the renderer. Embree
supports GPUs based on the Xe HPG and Xe HPC microarchitecture,
which support hardware accelerated ray tracing do deliver excellent
levels of ray tracing performance.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Supported Platforms</h2><a id="user-content-supported-platforms" class="anchor" aria-label="Permalink: Supported Platforms" href="#supported-platforms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embree supports Windows (32-bit and 64-bit), Linux (64-bit), and macOS
(64-bit). Under Windows, Linux and macOS x86 based CPUs are supported,
while ARM CPUs are currently only supported under Linux and macOS (e.g.
Apple M1). ARM support for Windows experimental.</p>
<p dir="auto">Embree supports Intel GPUs based on the Xe HPG microarchitecture
(Intel® Arc™ GPU) under Linux and Windows and Xe HPC microarchitecture
(Intel® Data Center GPU Flex Series and Intel® Data Center GPU Max
Series) under Linux.</p>
<p dir="auto">The code compiles with the Intel® Compiler, Intel® oneAPI DPC++
Compiler, GCC, Clang, and the Microsoft Compiler. To use Embree on the
GPU the Intel® oneAPI DPC++ Compiler must be used. Please see section
[Compiling Embree] for details on tested compiler versions.</p>
<p dir="auto">Embree requires at least an x86 CPU with support for
SSE2 or an Apple M1 CPU.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Embree Support and Contact</h2><a id="user-content-embree-support-and-contact" class="anchor" aria-label="Permalink: Embree Support and Contact" href="#embree-support-and-contact"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you encounter bugs please report them via <a href="https://github.com/embree/embree/issues">Embree's GitHub Issue
Tracker</a>.</p>
<p dir="auto">For questions and feature requests please write us at
<a href="mailto:embree_support@intel.com">embree_support@intel.com</a>.</p>
<p dir="auto">To receive notifications of updates and new features of Embree please
subscribe to the <a href="https://groups.google.com/d/forum/embree/" rel="nofollow">Embree mailing
list</a>.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Installation of Embree</h1><a id="user-content-installation-of-embree" class="anchor" aria-label="Permalink: Installation of Embree" href="#installation-of-embree"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Windows Installation</h2><a id="user-content-windows-installation" class="anchor" aria-label="Permalink: Windows Installation" href="#windows-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A pre-built version of Embree for Windows is provided as a ZIP archive
<a href="https://github.com/embree/embree/releases/download/v4.4.0/embree-4.4.0.x64.windows.zip">embree-4.4.0.x64.windows.zip</a>. After
unpacking this ZIP file, you should set the path to the <code>lib</code> folder
manually to your <code>PATH</code> environment variable for applications to find
Embree.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Linux Installation</h2><a id="user-content-linux-installation" class="anchor" aria-label="Permalink: Linux Installation" href="#linux-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A pre-built version of Embree for Linux is provided as a <code>tar.gz</code> archive:
<a href="https://github.com/embree/embree/releases/download/v4.4.0/embree-4.4.0.x86_64.linux.tar.gz">embree-4.4.0.x86_64.linux.tar.gz</a>. Unpack
this file using <code>tar</code> and source the provided <code>embree-vars.sh</code> (if you
are using the bash shell) or <code>embree-vars.csh</code> (if you are using the C
shell) to set up the environment properly:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="tar xzf embree-4.4.0.x86_64.linux.tar.gz
source embree-4.4.0.x86_64.linux/embree-vars.sh"><pre class="notranslate"><code>tar xzf embree-4.4.0.x86_64.linux.tar.gz
source embree-4.4.0.x86_64.linux/embree-vars.sh
</code></pre></div>
<p dir="auto">We recommend adding a relative <code>RPATH</code> to your application that points
to the location where Embree (and TBB) can be found, e.g. <code>$ORIGIN/../lib</code>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">macOS Installation</h2><a id="user-content-macos-installation" class="anchor" aria-label="Permalink: macOS Installation" href="#macos-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The macOS version of Embree is also delivered as a ZIP file:
<a href="https://github.com/embree/embree/releases/download/v4.4.0/embree-4.4.0.x86_64.macosx.zip">embree-4.4.0.x86_64.macosx.zip</a>. Unpack
this file using <code>tar</code> and source the provided <code>embree-vars.sh</code> (if you
are using the bash shell) or <code>embree-vars.csh</code> (if you are using the C
shell) to set up the environment properly:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="unzip embree-4.4.0.x64.macosx.zip    source embree-4.4.0.x64.macosx/embree-vars.sh"><pre class="notranslate"><code>unzip embree-4.4.0.x64.macosx.zip    source embree-4.4.0.x64.macosx/embree-vars.sh
</code></pre></div>
<p dir="auto">If you want to ship Embree with your application, please use the Embree
library of the provided ZIP file. The library name of that Embree
library is of the form <code>@rpath/libembree.4.dylib</code>
(and similar also for the included TBB library). This ensures that you
can add a relative <code>RPATH</code> to your application that points to the location
where Embree (and TBB) can be found, e.g. <code>@loader_path/../lib</code>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Building Embree Applications</h2><a id="user-content-building-embree-applications" class="anchor" aria-label="Permalink: Building Embree Applications" href="#building-embree-applications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The most convenient way to build an Embree application is through
CMake. Just let CMake find your unpacked Embree package using the
<code>FIND_PACKAGE</code> function inside your <code>CMakeLists.txt</code> file:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content=" FIND_PACKAGE(embree 4 REQUIRED)"><pre class="notranslate"><code> FIND_PACKAGE(embree 4 REQUIRED)
</code></pre></div>
<p dir="auto">For CMake to properly find Embree you need to set the <code>embree_DIR</code> variable to
the folder containing the <code>embree_config.cmake</code> file. You might also have to
set the <code>TBB_DIR</code> variable to the path containing <code>TBB-config.cmake</code> of a local
TBB install, in case you do not have TBB installed globally on your system,
e.g:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -D embree_DIR=path_to_embree_package/lib/cmake/embree-4.4.0/ \
      -D TBB_DIR=path_to_tbb_package/lib/cmake/tbb/ \
      .."><pre class="notranslate"><code>cmake -D embree_DIR=path_to_embree_package/lib/cmake/embree-4.4.0/ \
      -D TBB_DIR=path_to_tbb_package/lib/cmake/tbb/ \
      ..
</code></pre></div>
<p dir="auto">The <code>FIND_PACKAGE</code> function will create an <code>embree</code> target that
you can add to your target link libraries:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="TARGET_LINK_LIBRARIES(application embree)"><pre class="notranslate"><code>TARGET_LINK_LIBRARIES(application embree)
</code></pre></div>
<p dir="auto">For a full example on how to build an Embree application please have a
look at the <code>minimal</code> tutorial provided in the <code>src</code> folder of the
Embree package and also the contained <code>README.txt</code> file.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Building Embree SYCL Applications</h2><a id="user-content-building-embree-sycl-applications" class="anchor" aria-label="Permalink: Building Embree SYCL Applications" href="#building-embree-sycl-applications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Building Embree SYCL applications is also best done using
CMake. Please first get some compatible SYCL compiler and setup the
environment as decribed in sections [Linux SYCL Compilation] and
[Windows SYCL Compilation].</p>
<p dir="auto">Also perform the setup steps from the previous [Building Embree
Applications] section.</p>
<p dir="auto">Please also have a look at the [Minimal] tutorial that is provided
with the Embree release, for an example how to build a simple SYCL
application using CMake and Embree.</p>
<p dir="auto">To properly compile your SYCL application you have to add additional
SYCL compile flags for each C++ file that contains SYCL device side
code or kernels as described next.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">JIT Compilation</h3><a id="user-content-jit-compilation" class="anchor" aria-label="Permalink: JIT Compilation" href="#jit-compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We recommend using just in time compilation (JIT compilation) together
with [SYCL JIT caching] to compile Embree SYCL applications. For JIT
compilation add these options to the compilation phase of all C++
files that contain SYCL code:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64"><pre class="notranslate"><code>-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64
</code></pre></div>
<p dir="auto">These options enable SYCL two phase compilation (<code>-fsycl</code> option),
enable function pointer support (<code>-Xclang -fsycl-allow-func-ptr</code>
option), and just in time (JIT) compilation only
(<code>-fsycl-targets=spir64</code> option).</p>
<p dir="auto">The following link options have to get added to the linking stage of
your application when using just in time compilation:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="-fsycl -fsycl-targets=spir64"><pre class="notranslate"><code>-fsycl -fsycl-targets=spir64
</code></pre></div>
<p dir="auto">For a full example on how to build an Embree SYCL application please
have a look at the SYCL version of the <code>minimal</code> tutorial provided in
the <code>src</code> folder of the Embree package and also the contained
<code>README.txt</code> file.</p>
<p dir="auto">Please have a look at the [Compiling Embree] section on how to create
an Embree package from sources if required.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">AOT Compilation</h3><a id="user-content-aot-compilation" class="anchor" aria-label="Permalink: AOT Compilation" href="#aot-compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Ahead of time compilation (AOT compilation) allows to speed up first
application start up time as device binaries are precompiled. We do
not recommend using AOT compilation as it does not allow the usage of
specialization constants to reduce code complexity.</p>
<p dir="auto">For ahead of time compilation add these compile options to the
compilation phase of all C++ files that contain SYCL code:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64_gen"><pre class="notranslate"><code>-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64_gen
</code></pre></div>
<p dir="auto">These options enable SYCL two phase compilation (<code>-fsycl</code> option),
enable function pointer support (<code>-Xclang -fsycl-allow-func-ptr</code>
option), and ahead of time (AOT) compilation
(<code>-fsycl-targets=spir64_gen</code> option).</p>
<p dir="auto">The following link options have to get added to the linking stage of
your application when compiling ahead of time for Xe HPG devices:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="-fsycl -fsycl-targets=spir64_gen
-Xsycl-target-backend=spir64_gen &quot;-device XE_HPG_CORE&quot;"><pre class="notranslate"><code>-fsycl -fsycl-targets=spir64_gen
-Xsycl-target-backend=spir64_gen "-device XE_HPG_CORE"
</code></pre></div>
<p dir="auto">This in particular configures the devices for AOT compilation to
<code>XE_HPG_CORE</code>.</p>
<p dir="auto">To get a list of all device supported by AOT compilation look at the
help of the device option in ocloc tool:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ocloc compile --help"><pre class="notranslate"><code>ocloc compile --help
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Building Embree Tests</h2><a id="user-content-building-embree-tests" class="anchor" aria-label="Permalink: Building Embree Tests" href="#building-embree-tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embree is released with a bundle of tests in an optional testing package.
To run these tests extract the testing package in the same folder as your embree installation.
e.g.:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="tar -xzf embree-4.4.0-testing.zip -C /path/to/installed/embree"><pre class="notranslate"><code>tar -xzf embree-4.4.0-testing.zip -C /path/to/installed/embree
</code></pre></div>
<p dir="auto">The tests are extracted into a new folder inside you embree installation and can be run with:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cd /path/to/installed/embree/testing
cmake -B build
cmake --build build target=tests"><pre class="notranslate"><code>cd /path/to/installed/embree/testing
cmake -B build
cmake --build build target=tests
</code></pre></div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Compiling Embree</h1><a id="user-content-compiling-embree" class="anchor" aria-label="Permalink: Compiling Embree" href="#compiling-embree"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We recommend using the prebuild Embree packages from
<a href="https://github.com/embree/embree/releases">https://github.com/embree/embree/releases</a>. If
you need to compile Embree yourself you need to use CMake as described
in the following.</p>
<p dir="auto">Do not enable fast-math optimizations in your compiler as this mode is
not supported by Embree.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Linux and macOS</h2><a id="user-content-linux-and-macos" class="anchor" aria-label="Permalink: Linux and macOS" href="#linux-and-macos"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To compile Embree you need a modern C++ compiler that supports
C++11. Embree is tested with the following compilers:</p>
<p dir="auto">Linux</p>
<ul dir="auto">
<li>Intel® oneAPI DPC++/C++ Compiler 2024.0.2</li>
<li>oneAPI DPC++/C++ Compiler 2023-10-26</li>
<li>Clang 5.0.0</li>
<li>Clang 4.0.0</li>
<li>GCC 10.0.1 (Fedora 32) AVX512 support</li>
<li>GCC  8.3.1 (Fedora 29) AVX512 support</li>
<li>Intel® Implicit SPMD Program Compiler 1.22.0</li>
</ul>
<p dir="auto">macOS x86_64</p>
<ul dir="auto">
<li>Apple Clang 15</li>
</ul>
<p dir="auto">macOS Arm64</p>
<ul dir="auto">
<li>Apple Clang 14</li>
</ul>
<p dir="auto">Embree supports using the Intel® Threading Building Blocks (TBB) as the
tasking system. For performance and flexibility reasons we recommend
using Embree with the Intel® Threading Building Blocks (TBB) and best
also use TBB inside your application. Optionally you can disable TBB
in Embree through the <code>EMBREE_TASKING_SYSTEM</code> CMake variable.</p>
<p dir="auto">Embree supports the Intel® Implicit SPMD Program Compiler (Intel® ISPC), which allows
straightforward parallelization of an entire renderer. If you
want to use Intel® ISPC then you can enable <code>EMBREE_ISPC_SUPPORT</code> in
CMake. Download and install the Intel® ISPC binaries from
<a href="https://ispc.github.io/downloads.html" rel="nofollow">ispc.github.io</a>. After
installation, put the path to <code>ispc</code> permanently into your <code>PATH</code> environment
variable or you set the <code>EMBREE_ISPC_EXECUTABLE</code> variable to point at the ISPC
executable during CMake configuration.</p>
<p dir="auto">You additionally have to install CMake 3.1.0 or higher and the developer
version of <a href="https://www.glfw.org/" rel="nofollow">GLFW</a> version 3.</p>
<p dir="auto">Under macOS, all these dependencies can be installed
using <a href="http://www.macports.org/" rel="nofollow">MacPorts</a>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo port install cmake tbb glfw-devel"><pre class="notranslate"><code>sudo port install cmake tbb glfw-devel
</code></pre></div>
<p dir="auto">Depending on your Linux distribution you can install these dependencies
using <code>yum</code> or <code>apt-get</code>.  Some of these packages might already be
installed or might have slightly different names.</p>
<p dir="auto">Type the following to install the dependencies using <code>yum</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo yum install cmake
sudo yum install tbb-devel
sudo yum install glfw-devel"><pre class="notranslate"><code>sudo yum install cmake
sudo yum install tbb-devel
sudo yum install glfw-devel
</code></pre></div>
<p dir="auto">Type the following to install the dependencies using <code>apt-get</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo apt-get install cmake-curses-gui
sudo apt-get install libtbb-dev
sudo apt-get install libglfw3-dev"><pre class="notranslate"><code>sudo apt-get install cmake-curses-gui
sudo apt-get install libtbb-dev
sudo apt-get install libglfw3-dev
</code></pre></div>
<p dir="auto">Finally, you can compile Embree using CMake. Create a build directory
inside the Embree root directory and execute <code>ccmake ..</code> inside this
build directory.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="mkdir build
cd build
ccmake .."><pre class="notranslate"><code>mkdir build
cd build
ccmake ..
</code></pre></div>
<p dir="auto">Per default, CMake will use the compilers specified with the <code>CC</code> and
<code>CXX</code> environment variables. Should you want to use a different
compiler, run <code>cmake</code> first and set the <code>CMAKE_CXX_COMPILER</code> and
<code>CMAKE_C_COMPILER</code> variables to the desired compiler. For example, to
use the Clang compiler instead of the default GCC on most Linux machines
(<code>g++</code> and <code>gcc</code>), execute</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang .."><pre class="notranslate"><code>cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ..
</code></pre></div>
<p dir="auto">Running <code>ccmake</code> will open a dialog where you can perform various
configurations as described below in [CMake Configuration]. After having
configured Embree, press <code>c</code> (for configure) and <code>g</code> (for generate) to
generate a Makefile and leave the configuration. The code can be
compiled by executing make.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="make -j 8"><pre class="notranslate"><code>make -j 8
</code></pre></div>
<p dir="auto">The executables will be generated inside the build folder. We recommend
installing the Embree library and header files on your
system. Therefore set the <code>CMAKE_INSTALL_PREFIX</code> to <code>/usr</code> in cmake
and type:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo make install"><pre class="notranslate"><code>sudo make install
</code></pre></div>
<p dir="auto">If you keep the default <code>CMAKE_INSTALL_PREFIX</code> of <code>/usr/local</code> then
you have to make sure the path <code>/usr/local/lib</code> is in your
<code>LD_LIBRARY_PATH</code>.</p>
<p dir="auto">You can also uninstall Embree again by executing:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo make uninstall"><pre class="notranslate"><code>sudo make uninstall
</code></pre></div>
<p dir="auto">You can also create an Embree package using the following command:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="make package"><pre class="notranslate"><code>make package
</code></pre></div>
<p dir="auto">Please see the [Building Embree Applications] section on how to build
your application with such an Embree package.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Linux SYCL Compilation</h2><a id="user-content-linux-sycl-compilation" class="anchor" aria-label="Permalink: Linux SYCL Compilation" href="#linux-sycl-compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There are two options to compile Embree with SYCL support:
The open source <a href="https://github.com/intel/llvm/">"oneAPI DPC++ Compiler"</a> or
the <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp" rel="nofollow">"Intel(R) oneAPI DPC++/C++ Compiler"</a>.
Other SYCL compilers are not supported.</p>
<p dir="auto">The "oneAPI DPC++ Compiler" is more up-to-date than the "Intel(R) oneAPI
DPC++/C++ Compiler" but less stable. The current tested version of the "oneAPI
DPC++ compiler is</p>
<ul dir="auto">
<li><a href="https://github.com/intel/llvm/releases/tag/nightly-2023-10-26">oneAPI DPC++ Compiler 2023-10-26</a></li>
</ul>
<p dir="auto">The compiler can be downloaded and simply extracted. The oneAPI DPC++ compiler
can be set up executing the following commands in a Linux (bash) shell:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="export SYCL_BUNDLE_ROOT=path_to_dpcpp_compiler
export PATH=$SYCL_BUNDLE_ROOT/bin:$PATH
export CPATH=$SYCL_BUNDLE_ROOT/include:$CPATH
export LIBRARY_PATH=$SYCL_BUNDLE_ROOT/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=$SYCL_BUNDLE_ROOT/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$SYCL_BUNDLE_ROOT/linux/lib/x64:$LD_LIBRARY_PATH"><pre class="notranslate"><code>export SYCL_BUNDLE_ROOT=path_to_dpcpp_compiler
export PATH=$SYCL_BUNDLE_ROOT/bin:$PATH
export CPATH=$SYCL_BUNDLE_ROOT/include:$CPATH
export LIBRARY_PATH=$SYCL_BUNDLE_ROOT/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=$SYCL_BUNDLE_ROOT/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$SYCL_BUNDLE_ROOT/linux/lib/x64:$LD_LIBRARY_PATH
</code></pre></div>
<p dir="auto">where the <code>path_to_dpcpp_compiler</code> should point to the unpacked oneAPI DPC++
compiler. This will put <code>clang++</code> and <code>clang</code> from the oneAPI DPC++ Compiler
into your path.</p>
<p dir="auto">Please also install all Linux packages described in the previous
section.</p>
<p dir="auto">Now, you can configure Embree using CMake by executing the following command
in the Embree root directory:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build \
      -DCMAKE_CXX_COMPILER=clang++ \
      -DCMAKE_C_COMPILER=clang \
      -DEMBREE_SYCL_SUPPORT=ON"><pre class="notranslate"><code>cmake -B build \
      -DCMAKE_CXX_COMPILER=clang++ \
      -DCMAKE_C_COMPILER=clang \
      -DEMBREE_SYCL_SUPPORT=ON
</code></pre></div>
<p dir="auto">This will create a directory <code>build</code> to use as the CMake build directory,
configure the usage of the oneAPI DPC++ Compiler, and turn on SYCL support
through <code>EMBREE_SYCL_SUPPORT=ON</code>.</p>
<p dir="auto">Alternatively, you can download and run the installer of the</p>
<ul dir="auto">
<li><a href="https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp" rel="nofollow">Intel(R) oneAPI DPC++/C++ Compiler</a>.</li>
</ul>
<p dir="auto">After installation, you can set up the compiler by sourcing the
<code>vars.sh</code> script in the <code>env</code> directory of the compiler install directory, for example,</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="source /opt/intel/oneAPI/compiler/latest/env/vars.sh"><pre class="notranslate"><code>source /opt/intel/oneAPI/compiler/latest/env/vars.sh
</code></pre></div>
<p dir="auto">This script will put the <code>icpx</code> and <code>icx</code> compiler executables from the
Intel(R) oneAPI DPC++/C++ Compiler in your path.</p>
<p dir="auto">Now, you can configure Embree using CMake by executing the following command
in the Embree root directory:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build \
      -DCMAKE_CXX_COMPILER=icpx \
      -DCMAKE_C_COMPILER=icx \
      -DEMBREE_SYCL_SUPPORT=ON"><pre class="notranslate"><code>cmake -B build \
      -DCMAKE_CXX_COMPILER=icpx \
      -DCMAKE_C_COMPILER=icx \
      -DEMBREE_SYCL_SUPPORT=ON
</code></pre></div>
<p dir="auto">More information about setting up the Intel(R) oneAPI DPC++/C++ compiler can be
found in the <a href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup.html" rel="nofollow">Development Reference Guide</a>. Please note, that the Intel(R) oneAPI DPC++/C++ compiler
requires <a href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup/use-the-command-line/use-cmake-with-the-compiler.html" rel="nofollow">at least CMake version 3.20.5 on Linux</a>.</p>
<p dir="auto">Independent of the DPC++ compiler choice, you can now build Embree using</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake --build build -j 8"><pre class="notranslate"><code>cmake --build build -j 8
</code></pre></div>
<p dir="auto">The executables will be generated inside the build folder. The
executable names of the SYCL versions of the tutorials end with
<code>_sycl</code>.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Linux Graphics Driver Installation</h3><a id="user-content-linux-graphics-driver-installation" class="anchor" aria-label="Permalink: Linux Graphics Driver Installation" href="#linux-graphics-driver-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To run the SYCL code you need to install the latest GPGPU drivers for
your Intel Xe HPG/HPC GPUs from here
<a href="https://dgpu-docs.intel.com/" rel="nofollow">https://dgpu-docs.intel.com/</a>. Follow
the driver installation instructions for your graphics card and
operating system.</p>
<p dir="auto">After installing the drivers you have to install an additional package
manually using</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo apt install intel-level-zero-gpu-raytracing"><pre class="notranslate"><code>sudo apt install intel-level-zero-gpu-raytracing
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Windows</h2><a id="user-content-windows" class="anchor" aria-label="Permalink: Windows" href="#windows"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embree is tested using the following compilers under Windows:</p>
<ul dir="auto">
<li>Intel® oneAPI DPC++/C++ Compiler 2024.0.2</li>
<li>oneAPI DPC++/C++ Compiler 2023-10-26</li>
<li>Visual Studio 2022</li>
<li>Visual Studio 2019</li>
<li>Visual Studio 2017</li>
<li>Intel® Implicit SPMD Program Compiler 1.22.0</li>
</ul>
<p dir="auto">To compile Embree for AVX-512 you have to use the Intel® Compiler.</p>
<p dir="auto">Embree supports using the Intel® Threading Building Blocks (TBB) as the
tasking system. For performance and flexibility reasons we recommend
using use Embree with the Intel® Threading Building Blocks (TBB) and best
also use TBB inside your application. Optionally you can disable TBB
in Embree through the <code>EMBREE_TASKING_SYSTEM</code> CMake variable.</p>
<p dir="auto">Embree will either find the Intel® Threading Building Blocks (TBB)
installation that comes with the Intel® Compiler, or you can install the
binary distribution of TBB directly from
<a href="https://github.com/oneapi-src/oneTBB/releases">https://github.com/oneapi-src/oneTBB/releases</a>
into a folder named <code>tbb</code> into your Embree root directory. You also have
to make sure that the libraries <code>tbb.dll</code> and <code>tbb_malloc.dll</code> can be
found when executing your Embree applications, e.g. by putting the path
to these libraries into your <code>PATH</code> environment variable.</p>
<p dir="auto">Embree supports the Intel® Implicit SPMD Program Compiler (Intel® ISPC), which
allows straightforward parallelization of an entire renderer. When installing
Intel® ISPC, make sure to download an Intel® ISPC version from
<a href="https://ispc.github.io/downloads.html" rel="nofollow">ispc.github.io</a> that is compatible with
your Visual Studio version. After installation, put the path to <code>ispc.exe</code>
permanently into your <code>PATH</code> environment variable or you need to correctly set
the <code>EMBREE_ISPC_EXECUTABLE</code> variable during CMake configuration to point to
the ISPC executable. If you want to use Intel® ISPC, you have to enable
<code>EMBREE_ISPC_SUPPORT</code> in CMake.</p>
<p dir="auto">You additionally have to install <a href="http://www.cmake.org/download/" rel="nofollow">CMake</a>
(version 3.1 or higher). Note that you need a native Windows CMake
installation because CMake under Cygwin cannot generate solution files
for Visual Studio.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Using the IDE</h3><a id="user-content-using-the-ide" class="anchor" aria-label="Permalink: Using the IDE" href="#using-the-ide"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Run <code>cmake-gui</code>, browse to the Embree sources, set the build directory
and click Configure. Now you can select the Generator, e.g. "Visual
Studio 12 2013" for a 32-bit build or "Visual Studio 12 2013 Win64"
for a 64-bit build.</p>
<p dir="auto">To use a different compiler than the Microsoft Visual C++ compiler, you
additionally need to specify the proper compiler toolset through the
option "Optional toolset to use (-T parameter)". E.g. to use Clang for
compilation set the toolset to "LLVM_v142".</p>
<p dir="auto">Do not change the toolset manually in a solution file (neither through
the project properties dialog nor through the "Use Intel Compiler"
project context menu), because then some compiler-specific command line
options cannot be set by CMake.</p>
<p dir="auto">Most configuration parameters described in the [CMake Configuration]
can be set under Windows as well. Finally, click "Generate" to create
the Visual Studio solution files.</p>
<p dir="auto">The following CMake options are only available under Windows:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>CMAKE_CONFIGURATION_TYPE</code>:  List of generated
configurations. The default value is Debug;Release;RelWithDebInfo.</p>
</li>
<li>
<p dir="auto"><code>USE_STATIC_RUNTIME</code>: Use the static version of the C/C++ runtime
library. This option is turned OFF by default.</p>
</li>
</ul>
<p dir="auto">Use the generated Visual Studio solution file <code>embree4.sln</code> to compile
the project.</p>
<p dir="auto">We recommend enabling syntax highlighting for the <code>.ispc</code> source and
<code>.isph</code> header files. To do so open Visual Studio, go to Tools ⇒
Options ⇒ Text Editor ⇒ File Extension and add the <code>isph</code> and <code>ispc</code>
extensions for the "Microsoft Visual C++" editor.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Using the Command Line</h3><a id="user-content-using-the-command-line" class="anchor" aria-label="Permalink: Using the Command Line" href="#using-the-command-line"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embree can also be configured and built without the IDE using the Visual
Studio command prompt:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cd path\to\embree
mkdir build
cd build
cmake -G &quot;Visual Studio 16 2019&quot; ..
cmake --build . --config Release"><pre class="notranslate"><code>cd path\to\embree
mkdir build
cd build
cmake -G "Visual Studio 16 2019" ..
cmake --build . --config Release
</code></pre></div>
<p dir="auto">You can also build only some projects with the <code>--target</code> switch.
Additional parameters after "<code>--</code>" will be passed to <code>msbuild</code>. For
example, to build the Embree library in parallel use</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake --build . --config Release --target embree -- /m"><pre class="notranslate"><code>cmake --build . --config Release --target embree -- /m
</code></pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Building Embree - Using vcpkg</h3><a id="user-content-building-embree---using-vcpkg" class="anchor" aria-label="Permalink: Building Embree - Using vcpkg" href="#building-embree---using-vcpkg"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can download and install Embree using the <a href="https://github.com/Microsoft/vcpkg">vcpkg</a> dependency manager:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
./vcpkg install embree3"><pre class="notranslate"><code>git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
./vcpkg install embree3
</code></pre></div>
<p dir="auto">The Embree port in vcpkg is kept up to date by Microsoft team members
and community contributors. If the version is out of date, please
<a href="https://github.com/Microsoft/vcpkg">create an issue or pull request</a>
on the vcpkg repository.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Windows SYCL Compilation</h2><a id="user-content-windows-sycl-compilation" class="anchor" aria-label="Permalink: Windows SYCL Compilation" href="#windows-sycl-compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There are two options to compile Embree with SYCL support:
The open source <a href="https://github.com/intel/llvm/">"oneAPI DPC++ Compiler"</a> or
the <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp" rel="nofollow">"Intel(R) oneAPI DPC++/C++ Compiler"</a>.
Other SYCL compilers are not supported. You will also need an installed version
of Visual Studio that supports the C++17 standard, e.g. Visual Studio 2019.</p>
<p dir="auto">The "oneAPI DPC++ Compiler" is more up-to-date than the "Intel(R) oneAPI
DPC++/C++ Compiler" but less stable. The current tested version of the oneAPI
DPC++ compiler is</p>
<ul dir="auto">
<li><a href="https://github.com/intel/llvm/releases/tag/nightly-2023-10-26">oneAPI DPC++ Compiler 2023-10-26</a></li>
</ul>
<p dir="auto">Download and unpack the archive and open the "x64 Native Tools Command Prompt"
of Visual Studio and execute the following lines to properly configure the
environment to use the oneAPI DPC++ compiler:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="set &quot;DPCPP_DIR=path_to_dpcpp_compiler&quot;
set &quot;PATH=%DPCPP_DIR%\bin;%PATH%&quot;
set &quot;PATH=%DPCPP_DIR%\lib;%PATH%&quot;
set &quot;CPATH=%DPCPP_DIR%\include;%CPATH%&quot;
set &quot;INCLUDE=%DPCPP_DIR%\include;%INCLUDE%&quot;
set &quot;LIB=%DPCPP_DIR%\lib;%LIB%&quot;"><pre class="notranslate"><code>set "DPCPP_DIR=path_to_dpcpp_compiler"
set "PATH=%DPCPP_DIR%\bin;%PATH%"
set "PATH=%DPCPP_DIR%\lib;%PATH%"
set "CPATH=%DPCPP_DIR%\include;%CPATH%"
set "INCLUDE=%DPCPP_DIR%\include;%INCLUDE%"
set "LIB=%DPCPP_DIR%\lib;%LIB%"
</code></pre></div>
<p dir="auto">The <code>path_to_dpcpp_compiler</code> should point to the unpacked oneAPI DPC++
compiler.</p>
<p dir="auto">Now, you can configure Embree using CMake by executing the following command
in the Embree root directory:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build
      -G Ninja
      -D CMAKE_BUILD_TYPE=Release
      -D CMAKE_CXX_COMPILER=clang++
      -D CMAKE_C_COMPILER=clang
      -D EMBREE_SYCL_SUPPORT=ON
      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb"><pre class="notranslate"><code>cmake -B build
      -G Ninja
      -D CMAKE_BUILD_TYPE=Release
      -D CMAKE_CXX_COMPILER=clang++
      -D CMAKE_C_COMPILER=clang
      -D EMBREE_SYCL_SUPPORT=ON
      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb
</code></pre></div>
<p dir="auto">This will create a directory <code>build</code> to use as the CMake build directory, and
configure a release build that uses <code>clang++</code> and <code>clang</code> from the oneAPI DPC++
compiler.</p>
<p dir="auto">The <a href="https://ninja-build.org/" rel="nofollow">Ninja</a> generator is currently the easiest way to
use the oneAPI DPC++ compiler.</p>
<p dir="auto">We also enable SYCL support in Embree using the <code>EMBREE_SYCL_SUPPORT</code> CMake
option.</p>
<p dir="auto">Alternatively, you can download and run the installer of the</p>
<ul dir="auto">
<li><a href="https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp" rel="nofollow">Intel(R) oneAPI DPC++/C++ Compiler</a>.</li>
</ul>
<p dir="auto">After installation, you can either open a regular <code>Command Prompt</code> and execute
the <code>vars.bat</code> script in the <code>env</code> directory of the compiler install directory,
for example</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="C:\Program Files (x86)\Intel\oneAPI\compiler\latest\env\vars.bat"><pre class="notranslate"><code>C:\Program Files (x86)\Intel\oneAPI\compiler\latest\env\vars.bat
</code></pre></div>
<p dir="auto">or simply open the installed "Intel oneAPI command prompt for Intel 64 for Visual Studio".</p>
<p dir="auto">Both ways will put the <code>icx</code> compiler executable from the
Intel(R) oneAPI DPC++/C++ compiler in your path.</p>
<p dir="auto">Now, you can configure Embree using CMake by executing the following command
in the Embree root directory:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build
      -G Ninja
      -D CMAKE_BUILD_TYPE=Release
      -D CMAKE_CXX_COMPILER=icx
      -D CMAKE_C_COMPILER=icx
      -D EMBREE_SYCL_SUPPORT=ON
      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb"><pre class="notranslate"><code>cmake -B build
      -G Ninja
      -D CMAKE_BUILD_TYPE=Release
      -D CMAKE_CXX_COMPILER=icx
      -D CMAKE_C_COMPILER=icx
      -D EMBREE_SYCL_SUPPORT=ON
      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb
</code></pre></div>
<p dir="auto">More information about setting up the Intel(R) oneAPI DPC++/C++ compiler can be
found in the <a href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup.html" rel="nofollow">Development Reference Guide</a>. Please note, that the Intel(R) oneAPI DPC++/C++ compiler
requires <a href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup/use-the-command-line/use-cmake-with-the-compiler.html" rel="nofollow">at least CMake version 3.23 on Windows</a>.</p>
<p dir="auto">Independent of the DPC++ compiler choice, you can now build Embree using</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake --build build"><pre class="notranslate"><code>cmake --build build
</code></pre></div>
<p dir="auto">If you have problems with Ninja re-running CMake in an infinite loop,
then first remove the "Re-run CMake if any of its inputs changed."
section from the <code>build.ninja</code> file and run the above command again.</p>
<p dir="auto">You can also create an Embree package using the following command:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake --build build --target package"><pre class="notranslate"><code>cmake --build build --target package
</code></pre></div>
<p dir="auto">Please see the [Building Embree SYCL Applications] section on how to build
your application with such an Embree package.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Windows Graphics Driver Installation</h3><a id="user-content-windows-graphics-driver-installation" class="anchor" aria-label="Permalink: Windows Graphics Driver Installation" href="#windows-graphics-driver-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In order to run the SYCL tutorials on HPG hardware, you first need to
install the graphics drivers for your graphics card from
<a href="https://www.intel.com" rel="nofollow">https://www.intel.com</a>. Please make sure to
have installed version 31.0.101.4644 or newer.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">CMake Configuration</h2><a id="user-content-cmake-configuration" class="anchor" aria-label="Permalink: CMake Configuration" href="#cmake-configuration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The default CMake configuration in the configuration dialog should be
appropriate for most usages. The following list describes all
parameters that can be configured in CMake:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>CMAKE_BUILD_TYPE</code>: Can be used to switch between Debug mode
(Debug), Release mode (Release) (default), and Release mode with
enabled assertions and debug symbols (RelWithDebInfo).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_STACK_PROTECTOR</code>: Enables protection of return address
from buffer overwrites. This option is OFF by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISPC_SUPPORT</code>: Enables Intel® ISPC support of Embree. This option
is OFF by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_SYCL_SUPPORT</code>: Enables GPU support using SYCL. When this
option is enabled you have to use some DPC++ compiler. Please see
the sections [Linux SYCL Compilation] and [Windows SYCL Compilation]
on supported DPC++ compilers. This option is OFF by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_SYCL_AOT_DEVICES</code>: Selects a list of GPU devices for
ahead-of-time (AOT) compilation of device code. Possible values are
either, "none" which enables only just in time (JIT) compilation, or
a list of the Embree-supported Xe GPUs for AOT compilation:</p>
<ul dir="auto">
<li>XE_HPG_CORE : Xe HPG devices</li>
<li>XE_HPC_CORE : Xe HPC devices</li>
</ul>
<p dir="auto">One can also specify multiple devices separated by comma to
compile ahead of time for multiple devices,
e.g. "XE_HPG_CORE,XE_HP_CORE". When enabling AOT compilation for one
or multiple devices, JIT compilation will always additionally be
enabled in case the code is executed on a device no code is
precompiled for.</p>
<p dir="auto">Execute "ocloc compile --help" for more details of possible devices
to pass. Embree is only supported on Xe HPG/HPC and newer devices.</p>
<p dir="auto">Per default, this option is set to "none" to enable JIT
compilation. We recommend using JIT compilation as this enables the
use of specialization constants to reduce code complexity.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_STATIC_LIB</code>: Builds Embree as a static library (OFF by
default). Further multiple static libraries are generated for the
different ISAs selected (e.g. <code>embree4.a</code>, <code>embree4_sse42.a</code>,
<code>embree4_avx.a</code>, <code>embree4_avx2.a</code>, <code>embree4_avx512.a</code>). You have
to link these libraries in exactly this order of increasing ISA.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_API_NAMESPACE</code>: Specifies a namespace name to put all Embree
API symbols inside. By default, no namespace is used and plain C symbols
are exported.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_LIBRARY_NAME</code>: Specifies the name of the Embree library file
created. By default, the name embree4 is used.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_IGNORE_CMAKE_CXX_FLAGS</code>: When enabled, Embree ignores
default CMAKE_CXX_FLAGS. This option is turned ON by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TUTORIALS</code>: Enables build of Embree tutorials (default ON).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_BACKFACE_CULLING</code>: Enables backface culling, i.e. only
surfaces facing a ray can be hit. This option is turned OFF by
default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_BACKFACE_CULLING_CURVES</code>: Enables backface culling for curves,
i.e. only surfaces facing a ray can be hit. This option is turned OFF
by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_BACKFACE_CULLING_SPHERES</code>: Enables backface culling for spheres,
i.e. only surfaces facing a ray can be hit. This option is turned OFF
by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_COMPACT_POLYS</code>: Enables compact tris/quads, i.e. only
geomIDs and primIDs are stored inside the leaf nodes.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_FILTER_FUNCTION</code>: Enables the intersection filter function
feature (ON by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_RAY_MASK</code>: Enables the ray masking feature (OFF by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_RAY_PACKETS</code>: Enables ray packet traversal kernels. This
feature is turned ON by default. When turned on packet traversal is
used internally and packets passed to rtcIntersect4/8/16 are kept
intact in callbacks (when the ISA of appropriate width is enabled).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_IGNORE_INVALID_RAYS</code>: Makes code robust against the risk of
full-tree traversals caused by invalid rays (e.g. rays containing
INF/NaN as origins). This option is turned OFF by default.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TASKING_SYSTEM</code>: Chooses between Intel® Threading TBB
Building Blocks (TBB), Parallel Patterns Library (PPL) (Windows
only), or an internal tasking system (INTERNAL). By default, TBB is
used.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TBB_ROOT</code>: If Intel® Threading Building Blocks (TBB)
is used as a tasking system, search the library in this directory
tree.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TBB_COMPONENT</code>: The component/library name of Intel® Threading
Building Blocks (TBB). Embree searches for this library name (default: tbb)
when TBB is used as the tasking system.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TBB_POSTFIX</code>: If Intel® Threading Building Blocks (TBB)
is used as a tasking system, link to tbb&lt;EMBREE_TBB_POSTFIX&gt;.(so,dll,lib).
Defaults to the empty string.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TBB_DEBUG_ROOT</code>: If Intel® Threading Building Blocks (TBB)
is used as a tasking system, search the library in this directory
tree in Debug mode. Defaults to <code>EMBREE_TBB_ROOT</code>.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_TBB_DEBUG_POSTFIX</code>: If Intel® Threading Building Blocks (TBB)
is used as a tasking system, link to tbb&lt;EMBREE_TBB_DEBUG_POSTFIX&gt;.(so,dll,lib)
in Debug mode. Defaults to "_debug".</p>
</li>
<li>
<p dir="auto"><code>EMBREE_MAX_ISA</code>: Select highest supported ISA (SSE2, SSE4.2, AVX,
AVX2, AVX512, or NONE). When set to NONE the
EMBREE_ISA_* variables can be used to enable ISAs individually. By
default, the option is set to AVX2.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISA_SSE2</code>: Enables SSE2 when EMBREE_MAX_ISA is set to
NONE. By default, this option is turned OFF.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISA_SSE42</code>: Enables SSE4.2 when EMBREE_MAX_ISA is set to
NONE. By default, this option is turned OFF.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISA_AVX</code>: Enables AVX when EMBREE_MAX_ISA is set to NONE. By
default, this option is turned OFF.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISA_AVX2</code>: Enables AVX2 when EMBREE_MAX_ISA is set to
NONE. By default, this option is turned OFF.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_ISA_AVX512</code>: Enables AVX-512 for Skylake when
EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_TRIANGLE</code>: Enables support for triangle geometries
(ON by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_QUAD</code>: Enables support for quad geometries (ON by
default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_CURVE</code>: Enables support for curve geometries (ON by
default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_SUBDIVISION</code>: Enables support for subdivision
geometries (ON by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_INSTANCE</code>: Enables support for instances (ON by
default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_INSTANCE_ARRAY</code>: Enables support for instance arrays (ON by
default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_USER</code>: Enables support for user-defined geometries
(ON by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_GEOMETRY_POINT</code>: Enables support for point geometries
(ON by default).</p>
</li>
<li>
<p dir="auto"><code>EMBREE_CURVE_SELF_INTERSECTION_AVOIDANCE_FACTOR</code>: Specifies a
factor that controls the self-intersection avoidance feature for flat
curves. Flat curve intersections which are closer than
curve_radius*<code>EMBREE_CURVE_SELF_INTERSECTION_AVOIDANCE_FACTOR</code> to
the ray origin are ignored. A value of 0.0f disables self-intersection
avoidance while 2.0f is the default value.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_DISC_POINT_SELF_INTERSECTION_AVOIDANCE</code>: Enables self-intersection
avoidance for RTC_GEOMETRY_TYPE_DISC_POINT geometry type (ON by default).
When enabled intersections are skipped if the ray origin lies inside the
sphere defined by the point primitive.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_MIN_WIDTH</code>: Enabled the min-width feature, which allows
increasing the radius of curves and points to match some amount of
pixels. See [rtcSetGeometryMaxRadiusScale] for more details.</p>
</li>
<li>
<p dir="auto"><code>EMBREE_MAX_INSTANCE_LEVEL_COUNT</code>: Specifies the maximum number of nested
instance levels. Should be greater than 0; the default value is 1.
Instances nested any deeper than this value will silently disappear in
release mode, and cause assertions in debug mode.</p>
</li>
</ul>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Embree Tutorials</h1><a id="user-content-embree-tutorials" class="anchor" aria-label="Permalink: Embree Tutorials" href="#embree-tutorials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embree comes with a set of tutorials aimed at helping users understand
how Embree can be used and extended. There is a very basic minimal
that can be compiled as both C and C++, which should get new users started quickly.
All other tutorials exist in an Intel® ISPC and C++ version to demonstrate
the two versions of the API. Look for files
named <code>tutorialname_device.ispc</code> for the Intel® ISPC implementation of the
tutorial, and files named <code>tutorialname_device.cpp</code> for the single ray C++
version of the tutorial. To start the C++ version use the <code>tutorialname</code>
executables, to start the Intel® ISPC version use the <code>tutorialname_ispc</code>
executables. All tutorials can print available command line options
using the <code>--help</code> command line parameter.</p>
<p dir="auto">For all tutorials except minimal, you can select an initial camera using
the <code>--vp</code> (camera position), <code>--vi</code> (camera look-at point), <code>--vu</code>
(camera up vector), and <code>--fov</code> (vertical field of view) command line
parameters:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./triangle_geometry --vp 10 10 10 --vi 0 0 0"><pre class="notranslate"><code>./triangle_geometry --vp 10 10 10 --vi 0 0 0
</code></pre></div>
<p dir="auto">You can select the initial window size using the <code>--size</code> command line
parameter, or start the tutorials in full screen using the <code>--fullscreen</code>
parameter:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./triangle_geometry --size 1024 1024
./triangle_geometry --fullscreen"><pre class="notranslate"><code>./triangle_geometry --size 1024 1024
./triangle_geometry --fullscreen
</code></pre></div>
<p dir="auto">The initialization string for the Embree device (<code>rtcNewDevice</code> call)
can be passed to the ray tracing core through the <code>--rtcore</code> command
line parameter, e.g.:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./triangle_geometry --rtcore verbose=2,threads=1"><pre class="notranslate"><code>./triangle_geometry --rtcore verbose=2,threads=1
</code></pre></div>
<p dir="auto">The navigation in the interactive display mode follows the camera orbit
model, where the camera revolves around the current center of interest.
With the left mouse button you can rotate around the center of interest
(the point initially set with <code>--vi</code>). Holding Control pressed while
clicking the left mouse button rotates the camera around its location.
You can also use the arrow keys for navigation.</p>
<p dir="auto">You can use the following keys:</p>
<p dir="auto">F1
:   Default shading</p>
<p dir="auto">F2
:   Gray EyeLight shading</p>
<p dir="auto">F3
:   Traces occlusion rays only.</p>
<p dir="auto">F4
:   UV Coordinate visualization</p>
<p dir="auto">F5
:   Geometry normal visualization</p>
<p dir="auto">F6
:   Geometry ID visualization</p>
<p dir="auto">F7
:   Geometry ID and Primitive ID visualization</p>
<p dir="auto">F8
:   Simple shading with 16 rays per pixel for benchmarking.</p>
<p dir="auto">F9
:   Switches to render cost visualization. Pressing again reduces
brightness.</p>
<p dir="auto">F10
:   Switches to render cost visualization. Pressing again increases
brightness.</p>
<p dir="auto">f
:   Enters or leaves full screen mode.</p>
<p dir="auto">c
:   Prints camera parameters.</p>
<p dir="auto">ESC
:   Exits the tutorial.</p>
<p dir="auto">q
:   Exits the tutorial.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Minimal</h2><a id="user-content-minimal" class="anchor" aria-label="Permalink: Minimal" href="#minimal"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial is designed to get new users started with Embree.
It can be compiled as both C and C++. It demonstrates how to initialize
a device and scene, and how to intersect rays with the scene.
There is no image output to keep the tutorial as simple as possible.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/minimal/minimal.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Host Device Memory</h2><a id="user-content-host-device-memory" class="anchor" aria-label="Permalink: Host Device Memory" href="#host-device-memory"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial shows four different ways to use explicit host and device memory
with SYCL.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/host_device_memory/host_device_memory_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Triangle Geometry</h2><a id="user-content-triangle-geometry" class="anchor" aria-label="Permalink: Triangle Geometry" href="#triangle-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/triangle_geometry/triangle_geometry_device.cpp"><img src="https://camo.githubusercontent.com/68550bd35b205eb57e6a8e6f6e15c202a5259cef762697215329a7ebaa9e5de6/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f747269616e676c655f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/triangle_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the creation of a static cube and ground
plane using triangle meshes. It also demonstrates the use of the
<code>rtcIntersect1</code> and <code>rtcOccluded1</code> functions to render primary visibility
and hard shadows. The cube sides are colored based on the ID of the hit
primitive.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/triangle_geometry/triangle_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Dynamic Scene</h2><a id="user-content-dynamic-scene" class="anchor" aria-label="Permalink: Dynamic Scene" href="#dynamic-scene"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/dynamic_scene/dynamic_scene_device.cpp"><img src="https://camo.githubusercontent.com/0eefc12115499f1a51c0685ade64145c0b8e5737ef39ce9ddec44ccc4d97d85f/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f64796e616d69635f7363656e652e6a7067" alt="" data-canonical-src="https://embree.github.io/images/dynamic_scene.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the creation of a dynamic scene, consisting
of several deforming spheres. Half of the spheres use the
<code>RTC_BUILD_QUALITY_REFIT</code> geometry build quality, which allows Embree
to use a refitting strategy for these spheres, the other half uses the
<code>RTC_BUILD_QUALITY_LOW</code> geometry build quality, causing a high
performance rebuild of their spatial data structure each frame. The
spheres are colored based on the ID of the hit sphere geometry.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/dynamic_scene/dynamic_scene_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Multi Scene Geometry</h2><a id="user-content-multi-scene-geometry" class="anchor" aria-label="Permalink: Multi Scene Geometry" href="#multi-scene-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/multiscene_geometry/multiscene_geometry_device.cpp"><img src="https://camo.githubusercontent.com/0eefc12115499f1a51c0685ade64145c0b8e5737ef39ce9ddec44ccc4d97d85f/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f64796e616d69635f7363656e652e6a7067" alt="" data-canonical-src="https://embree.github.io/images/dynamic_scene.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the creation of multiple scenes sharing the
same geometry objects.  Here, three scenes are built.  One with all
the dynamic spheres of the Dynamic Scene test and two others each with
half.  The ground plane is shared by all three scenes.  The space bar
is used to cycle the scene chosen for rendering.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/multiscene_geometry/multiscene_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">User Geometry</h2><a id="user-content-user-geometry" class="anchor" aria-label="Permalink: User Geometry" href="#user-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/user_geometry/user_geometry_device.cpp"><img src="https://camo.githubusercontent.com/d62b70bd880ee0ba4b0e3606c100852100f3f804698bce201320f49d17f2dff6/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f757365725f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/user_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial shows the use of user-defined geometry, to re-implement
instancing, and to add analytic spheres. A two-level scene is created,
with a triangle mesh as ground plane, and several user geometries that
instance other scenes with a small number of spheres of different kinds.
The spheres are colored using the instance ID and geometry ID of the hit
sphere, to demonstrate how the same geometry instanced in different
ways can be distinguished.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/user_geometry/user_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Viewer</h2><a id="user-content-viewer" class="anchor" aria-label="Permalink: Viewer" href="#viewer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/viewer/viewer_device.cpp"><img src="https://camo.githubusercontent.com/02a5017dc03037909726797c0804a0f6117105990e3425b43e26cc5ffa5168a1/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f7669657765722e6a7067" alt="" data-canonical-src="https://embree.github.io/images/viewer.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates a simple OBJ viewer that traces primary
visibility rays only. A scene consisting of multiple meshes is created,
each mesh sharing the index and vertex buffer with the application.
It also demonstrates how to support additional per-vertex data, such as
shading normals.</p>
<p dir="auto">You need to specify an OBJ file at the command line for this tutorial to
work:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./viewer -i model.obj"><pre class="notranslate"><code>./viewer -i model.obj
</code></pre></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/viewer/viewer_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Intersection Filter</h2><a id="user-content-intersection-filter" class="anchor" aria-label="Permalink: Intersection Filter" href="#intersection-filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/intersection_filter/intersection_filter_device.cpp"><img src="https://camo.githubusercontent.com/800e7cdbc36cd6874c23013f5116cd68728fa5a575e946d797448ed8e7dec58b/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f696e74657273656374696f6e5f66696c7465722e6a7067" alt="" data-canonical-src="https://embree.github.io/images/intersection_filter.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of filter callback functions to
efficiently implement transparent objects. The filter function used for
primary rays lets the ray pass through the geometry if it is entirely
transparent. Otherwise, the shading loop handles the transparency
properly, by potentially shooting secondary rays. The filter function
used for shadow rays accumulates the transparency of all surfaces along
the ray, and terminates traversal if an opaque occluder is hit.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/intersection_filter/intersection_filter_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Instanced Geometry</h2><a id="user-content-instanced-geometry" class="anchor" aria-label="Permalink: Instanced Geometry" href="#instanced-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/instanced_geometry/instanced_geometry_device.cpp"><img src="https://camo.githubusercontent.com/03d50a242364864ae6143a04060bb3b436cd5e68f03ded65afaa5c351b4a704d/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f696e7374616e6365645f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/instanced_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the in-build instancing feature of Embree, by
instancing a number of other scenes built from triangulated spheres. The
spheres are again colored using the instance ID and geometry ID of the
hit sphere, to demonstrate how the same geometry instanced in different
ways can be distinguished.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/instanced_geometry/instanced_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Instance Array Geometry</h2><a id="user-content-instance-array-geometry" class="anchor" aria-label="Permalink: Instance Array Geometry" href="#instance-array-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/forest/forest_device.cpp"><img src="https://camo.githubusercontent.com/fa2fc075daba863bd02a436daf578c9f69dd6f2d4ae3e853bc795d5258371e39/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f666f726573742e6a7067" alt="" data-canonical-src="https://embree.github.io/images/forest.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the usage of instance arrays in Embree. Instance arrays
are large collections of similar objects. Examples are sand dunes that consist
of millions of instances of a few grain models or, like here, a forest consisting of
many instances of a few tree models.</p>
<p dir="auto">In this application can switch between representing the scene with regular
instances or (one!) instance array. It also prints several stats, that
demonstrate the memory savings and faster BVH build times when using instance
arrays for such scenes. Instance arrays come with a small overhead on CPU and
should be preferred if memory consumption is more important than raytracing
performance.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/forest/forest_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Multi Level Instancing</h2><a id="user-content-multi-level-instancing" class="anchor" aria-label="Permalink: Multi Level Instancing" href="#multi-level-instancing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/multi_instanced_geometry/multi_instanced_geometry_device.cpp"><img src="https://camo.githubusercontent.com/35782caefaa75a7e8e671a4b60678e842a1c33f878c88b98033b6e930c343be9/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f6d756c74695f6c6576656c5f696e7374616e63696e672e6a7067" alt="" data-canonical-src="https://embree.github.io/images/multi_level_instancing.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates multi-level instancing, i.e., nesting instances
into instances. To enable the tutorial, set the compile-time variable
<code>EMBREE_MAX_INSTANCE_LEVEL_COUNT</code> to a value other than the default 1.
This variable is available in the code as <code>RTC_MAX_INSTANCE_LEVEL_COUNT</code>.</p>
<p dir="auto">The renderer uses a basic path tracing approach, and the
image will progressively refine over time.
There are two levels of instances in this scene: multiple instances of
the same tree nest instances of a twig.
Intersections on up to <code>RTC_MAX_INSTANCE_LEVEL_COUNT</code> nested levels of
instances work out of the box. Users may obtain the <em>instance ID stack</em> for
a given hitpoint from the <code>instID</code> member.
During shading, the instance ID stack is used to accumulate
normal transformation matrices for each hit. The tutorial visualizes
transformed normals as colors.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/multi_instanced_geometry/multi_instanced_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Path Tracer</h2><a id="user-content-path-tracer" class="anchor" aria-label="Permalink: Path Tracer" href="#path-tracer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/pathtracer/pathtracer_device.cpp"><img src="https://camo.githubusercontent.com/df783c08ef8ecbf357330d8487386826d88668ed74d5e2197c2c6a34ff9edff0/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f706174687472616365722e6a7067" alt="" data-canonical-src="https://embree.github.io/images/pathtracer.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial is a simple path tracer, based on the viewer tutorial.</p>
<p dir="auto">You need to specify an OBJ file and light source at the command line for
this tutorial to work:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./pathtracer -i model.obj --ambientlight 1 1 1"><pre class="notranslate"><code>./pathtracer -i model.obj --ambientlight 1 1 1
</code></pre></div>
<p dir="auto">As example models we provide the "Austrian Imperial Crown" model by
<a href="http://www.loramel.net" rel="nofollow">Martin Lubich</a> and the "Asian Dragon" model from the
<a href="http://graphics.stanford.edu/data/3Dscanrep/" rel="nofollow">Stanford 3D Scanning Repository</a>.</p>
<p dir="auto"><a href="https://github.com/embree/models/releases/download/release/crown.zip">crown.zip</a></p>
<p dir="auto"><a href="https://github.com/embree/models/releases/download/release/asian_dragon.zip">asian_dragon.zip</a></p>
<p dir="auto">To render these models execute the following:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./pathtracer -c crown/crown.ecs
./pathtracer -c asian_dragon/asian_dragon.ecs"><pre class="notranslate"><code>./pathtracer -c crown/crown.ecs
./pathtracer -c asian_dragon/asian_dragon.ecs
</code></pre></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/pathtracer/pathtracer_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Hair</h2><a id="user-content-hair" class="anchor" aria-label="Permalink: Hair" href="#hair"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/hair_geometry/hair_geometry_device.cpp"><img src="https://camo.githubusercontent.com/e90c9b3e6753059c52c4454ac8d7eb290386a8e205f493afc2496e5bc7fa6777/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f686169725f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/hair_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of the hair geometry to render a
hairball.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/hair_geometry/hair_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Curve Geometry</h2><a id="user-content-curve-geometry" class="anchor" aria-label="Permalink: Curve Geometry" href="#curve-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/curve_geometry/curve_geometry_device.cpp"><img src="https://camo.githubusercontent.com/373a9ef4e6bb8ba77f8a5c72a71ae295adaf73a2fc0bd529c2ce0e3b86c7cf8a/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f63757276655f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/curve_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of the Linear Basis, B-Spline, and Catmull-Rom curve geometries.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/curve_geometry/curve_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Subdivision Geometry</h2><a id="user-content-subdivision-geometry" class="anchor" aria-label="Permalink: Subdivision Geometry" href="#subdivision-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/subdivision_geometry/subdivision_geometry_device.cpp"><img src="https://camo.githubusercontent.com/a5c361356fe40778b51e33efcb772c28c98eb4bab32511af94cf2120b623e2f2/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f7375626469766973696f6e5f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/subdivision_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of Catmull-Clark subdivision
surfaces.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/subdivision_geometry/subdivision_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Displacement Geometry</h2><a id="user-content-displacement-geometry" class="anchor" aria-label="Permalink: Displacement Geometry" href="#displacement-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/displacement_geometry/displacement_geometry_device.cpp"><img src="https://camo.githubusercontent.com/41d0e2f156241ac876b4f406ddc81a9e929c67c3cf89e766282e77542a9442a9/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f646973706c6163656d656e745f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/displacement_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of Catmull-Clark subdivision
surfaces with procedural displacement mapping using a constant edge
tessellation level.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/displacement_geometry/displacement_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Grid Geometry</h2><a id="user-content-grid-geometry" class="anchor" aria-label="Permalink: Grid Geometry" href="#grid-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/tree/master/tutorials/grid_geometry"><img src="https://camo.githubusercontent.com/c066e85fec9ffa1351ac4f8be309447803cff2c886f3d71d60ff8eaa60515087/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f677269645f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/grid_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of the memory efficient grid
primitive to handle highly tessellated and displaced geometry.</p>
<p dir="auto"><a href="https://github.com/embree/embree/tree/master/tutorials/grid_geometry">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Point Geometry</h2><a id="user-content-point-geometry" class="anchor" aria-label="Permalink: Point Geometry" href="#point-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/point_geometry/point_geometry_device.cpp"><img src="https://camo.githubusercontent.com/1f330efdb6d0de47c0dea2c2e2ec8db6d34291763536f773365368dd1c284b8c/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f706f696e745f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/point_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates the use of the three representations
of point geometry.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/point_geometry/point_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Motion Blur Geometry</h2><a id="user-content-motion-blur-geometry" class="anchor" aria-label="Permalink: Motion Blur Geometry" href="#motion-blur-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/motion_blur_geometry/motion_blur_geometry_device.cpp"><img src="https://camo.githubusercontent.com/cc477a0768f2f36bd22b634842c56b42a4d5eaa47d6964ad8873261d4c15cdaf/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f6d6f74696f6e5f626c75725f67656f6d657472792e6a7067" alt="" data-canonical-src="https://embree.github.io/images/motion_blur_geometry.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates rendering of motion blur using the
multi-segment motion blur feature. Shown is motion blur of a triangle mesh,
quad mesh, subdivision surface, line segments, hair geometry, Bézier
curves, instantiated triangle mesh where the instance moves,
instantiated quad mesh where the instance and the quads move, and user
geometry.</p>
<p dir="auto">The number of time steps used can be configured using the <code>--time-steps &lt;int&gt;</code> and <code>--time-steps2 &lt;int&gt;</code> command line parameters, and the
geometry can be rendered at a specific time using the the <code>--time &lt;float&gt;</code> command line parameter.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/motion_blur_geometry/motion_blur_geometry_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Quaternion Motion Blur</h2><a id="user-content-quaternion-motion-blur" class="anchor" aria-label="Permalink: Quaternion Motion Blur" href="#quaternion-motion-blur"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/quaternion_motion_blur/quaternion_motion_blur_device.cpp"><img src="https://camo.githubusercontent.com/c2599e9f606a166f532e77d6c7eca8b1dbbb29967d44d2aa4b22811638d2bb9b/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f7175617465726e696f6e5f6d6f74696f6e5f626c75722e6a7067" alt="" data-canonical-src="https://embree.github.io/images/quaternion_motion_blur.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates rendering of motion blur using quaternion
interpolation. Shown is motion blur using spherical linear interpolation of
the rotational component of the instance transformation on the left and
simple linear interpolation of the instance transformation on the right. The
number of time steps can be modified as well.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/quaternion_motion_blur/quaternion_motion_blur_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Interpolation</h2><a id="user-content-interpolation" class="anchor" aria-label="Permalink: Interpolation" href="#interpolation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/interpolation/interpolation_device.cpp"><img src="https://camo.githubusercontent.com/c23e93bb3cc8e3b0ca36c325213d03d506b7fab59bfb6900ab987f720fa9ab9f/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f696e746572706f6c6174696f6e2e6a7067" alt="" data-canonical-src="https://embree.github.io/images/interpolation.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates interpolation of user-defined per-vertex data.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/interpolation/interpolation_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Closest Point</h2><a id="user-content-closest-point" class="anchor" aria-label="Permalink: Closest Point" href="#closest-point"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/closest_point/closest_point_device.cpp"><img src="https://camo.githubusercontent.com/a9cd365357743ca8d63045088d79679083f051958dad36202ca5534152aa43c1/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f636c6f736573745f706f696e742e6a7067" alt="" data-canonical-src="https://embree.github.io/images/closest_point.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates a use-case of the point query API. The scene
consists of a simple collection of objects that are instanced and for several
point in the scene (red points) the closest point on the surfaces of the
scene are computed (white points). The closest point functionality is
implemented for Embree internal and for user-defined instancing. The tutorial
also illustrates how to handle instance transformations that are not
similarity transforms.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/closest_point/closest_point_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Voronoi</h2><a id="user-content-voronoi" class="anchor" aria-label="Permalink: Voronoi" href="#voronoi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/voronoi/voronoi_device.cpp"><img src="https://camo.githubusercontent.com/b60dba1c19952c45b401d67a39aff0d1bc7f112a62770c72de8caa35886687c5/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f766f726f6e6f692e6a7067" alt="" data-canonical-src="https://embree.github.io/images/voronoi.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates how to implement nearest neighbour lookups using
the point query API. Several colored points are located on a plane and the
corresponding voroni regions are illustrated.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/voronoi/voronoi_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Collision Detection</h2><a id="user-content-collision-detection" class="anchor" aria-label="Permalink: Collision Detection" href="#collision-detection"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/collide/collide_device.cpp"><img src="https://camo.githubusercontent.com/03fcd79aec92ef91baf9927312de09a6de109d106d4461584e9c0ae2f0004331/68747470733a2f2f656d627265652e6769746875622e696f2f696d616765732f636f6c6c6964652e6a7067" alt="" data-canonical-src="https://embree.github.io/images/collide.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">This tutorial demonstrates how to implement collision detection using
the collide API. A simple cloth solver is setup to collide with a sphere.</p>
<p dir="auto">The cloth can be reset with the <code>space</code> bar.  The sim stepped once with <code>n</code>
and continuous simulation started and paused with <code>p</code>.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/collide/collide_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">BVH Builder</h2><a id="user-content-bvh-builder" class="anchor" aria-label="Permalink: BVH Builder" href="#bvh-builder"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial demonstrates how to use the templated hierarchy builders
of Embree to build a bounding volume hierarchy with a user-defined
memory layout using a high-quality SAH builder using spatial splits, a
standard SAH builder, and a very fast Morton builder.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/bvh_builder/bvh_builder_device.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">BVH Access</h2><a id="user-content-bvh-access" class="anchor" aria-label="Permalink: BVH Access" href="#bvh-access"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial demonstrates how to access the internal triangle
acceleration structure build by Embree. Please be aware that the
internal Embree data structures might change between Embree updates.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/bvh_access/bvh_access.cpp">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Find Embree</h2><a id="user-content-find-embree" class="anchor" aria-label="Permalink: Find Embree" href="#find-embree"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial demonstrates how to use the <code>FIND_PACKAGE</code> CMake feature
to use an installed Embree. Under Linux and macOS the tutorial finds
the Embree installation automatically, under Windows the <code>embree_DIR</code>
CMake variable must be set to the following folder of the Embree
installation: <code>C:\Program Files\Intel\Embree3</code>.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/find_embree/CMakeLists.txt">Source Code</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Next Hit</h2><a id="user-content-next-hit" class="anchor" aria-label="Permalink: Next Hit" href="#next-hit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This tutorial demonstrates how to robustly enumerate all hits along
the ray using multiple ray queries and an intersection filter
function. To improve performance, the tutorial also supports
collecting the next N hits in a single ray query.</p>
<p dir="auto"><a href="https://github.com/embree/embree/blob/master/tutorials/next_hit/next_hit_device.cpp">Source Code</a></p>
</article></div>