<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">fast_float number parsing library: 4x faster than strtod</h2><a id="user-content-fast_float-number-parsing-library-4x-faster-than-strtod" class="anchor" aria-label="Permalink: fast_float number parsing library: 4x faster than strtod" href="#fast_float-number-parsing-library-4x-faster-than-strtod"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/fastfloat/fast_float/actions/workflows/ubuntu22.yml"><img src="https://github.com/fastfloat/fast_float/actions/workflows/ubuntu22.yml/badge.svg" alt="Ubuntu 22.04 CI (GCC 11)" style="max-width: 100%;"></a></p>
<p dir="auto">The fast_float library provides fast header-only implementations for the C++
from_chars functions for <code>float</code> and <code>double</code> types as well as integer types.
These functions convert ASCII strings representing decimal values (e.g.,
<code>1.3e10</code>) into binary types. We provide exact rounding (including round to
even). In our experience, these <code>fast_float</code> functions many times faster than
comparable number-parsing functions from existing C++ standard libraries.</p>
<p dir="auto">Specifically, <code>fast_float</code> provides the following two functions to parse
floating-point numbers with a C++17-like syntax (the library itself only
requires C++11):</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="from_chars_result from_chars(char const *first, char const *last, float &amp;value, ...);
from_chars_result from_chars(char const *first, char const *last, double &amp;value, ...);"><pre>from_chars_result <span class="pl-en">from_chars</span>(<span class="pl-k">char</span> <span class="pl-k">const</span> *first, <span class="pl-k">char</span> <span class="pl-k">const</span> *last, <span class="pl-k">float</span> &amp;value, ...);
from_chars_result <span class="pl-en">from_chars</span>(<span class="pl-k">char</span> <span class="pl-k">const</span> *first, <span class="pl-k">char</span> <span class="pl-k">const</span> *last, <span class="pl-k">double</span> &amp;value, ...);</pre></div>
<p dir="auto">You can also parse integer types:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="from_chars_result from_chars(char const *first, char const *last, int &amp;value, ...);
from_chars_result from_chars(char const *first, char const *last, unsigned &amp;value, ...);"><pre>from_chars_result <span class="pl-en">from_chars</span>(<span class="pl-k">char</span> <span class="pl-k">const</span> *first, <span class="pl-k">char</span> <span class="pl-k">const</span> *last, <span class="pl-k">int</span> &amp;value, ...);
from_chars_result <span class="pl-en">from_chars</span>(<span class="pl-k">char</span> <span class="pl-k">const</span> *first, <span class="pl-k">char</span> <span class="pl-k">const</span> *last, <span class="pl-k">unsigned</span> &amp;value, ...);</pre></div>
<p dir="auto">The return type (<code>from_chars_result</code>) is defined as the struct:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct from_chars_result {
  char const *ptr;
  std::errc ec;
};"><pre><span class="pl-k">struct</span> <span class="pl-en">from_chars_result</span> {
  <span class="pl-k">char</span> <span class="pl-k">const</span> *ptr;
  std::errc ec;
};</pre></div>
<p dir="auto">It parses the character sequence <code>[first, last)</code> for a number. It parses
floating-point numbers expecting a locale-independent format equivalent to the
C++17 from_chars function. The resulting floating-point value is the closest
floating-point values (using either <code>float</code> or <code>double</code>), using the "round to
even" convention for values that would otherwise fall right in-between two
values. That is, we provide exact parsing according to the IEEE standard.</p>
<p dir="auto">Given a successful parse, the pointer (<code>ptr</code>) in the returned value is set to
point right after the parsed number, and the <code>value</code> referenced is set to the
parsed value. In case of error, the returned <code>ec</code> contains a representative
error, otherwise the default (<code>std::errc()</code>) value is stored.</p>
<p dir="auto">The implementation does not throw and does not allocate memory (e.g., with <code>new</code>
or <code>malloc</code>).</p>
<p dir="auto">It will parse infinity and nan values.</p>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string input = &quot;3.1416 xyz &quot;;
  double result;
  auto answer = fast_float::from_chars(input.data(), input.data() + input.size(), result);
  if (answer.ec != std::errc()) { std::cerr &lt;&lt; &quot;parsing failure\n&quot;; return EXIT_FAILURE; }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; result &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>3.1416 xyz <span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<p dir="auto">Though the C++17 standard has you do a comparison with <code>std::errc()</code> to check whether the conversion worked, you can avoid it by casting the result to a <code>bool</code> like so:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string input = &quot;3.1416 xyz &quot;;
  double result;
  if(auto answer = fast_float::from_chars(input.data(), input.data() + input.size(), result)) {
    std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; result &lt;&lt; std::endl;
    return EXIT_SUCCESS;
  }
  std::cerr &lt;&lt; &quot;failed to parse &quot; &lt;&lt; result &lt;&lt; std::endl;
  return EXIT_FAILURE;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>3.1416 xyz <span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  <span class="pl-k">if</span>(<span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result)) {
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
    <span class="pl-k">return</span> EXIT_SUCCESS;
  }
  std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>failed to parse <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_FAILURE;
}</pre></div>
<p dir="auto">You can parse delimited numbers:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  std::string input = &quot;234532.3426362,7869234.9823,324562.645&quot;;
  double result;
  auto answer = fast_float::from_chars(input.data(), input.data() + input.size(), result);
  if (answer.ec != std::errc()) {
    // check error
  }
  // we have result == 234532.3426362.
  if (answer.ptr[0] != ',') {
    // unexpected delimiter
  }
  answer = fast_float::from_chars(answer.ptr + 1, input.data() + input.size(), result);
  if (answer.ec != std::errc()) {
    // check error
  }
  // we have result == 7869234.9823.
  if (answer.ptr[0] != ',') {
    // unexpected delimiter
  }
  answer = fast_float::from_chars(answer.ptr + 1, input.data() + input.size(), result);
  if (answer.ec != std::errc()) {
    // check error
  }
  // we have result == 324562.645."><pre>  std::string input = <span class="pl-s"><span class="pl-pds">"</span>234532.3426362,7869234.9823,324562.645<span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  <span class="pl-k">auto</span> answer = fast_float::from_chars(input.data(), input.data() + input.size(), result);
  <span class="pl-k">if</span> (answer.ec != std::errc()) {
    <span class="pl-c"><span class="pl-c">//</span> check error</span>
  }
  <span class="pl-c"><span class="pl-c">//</span> we have result == 234532.3426362.</span>
  <span class="pl-k">if</span> (answer.ptr[<span class="pl-c1">0</span>] != <span class="pl-s"><span class="pl-pds">'</span>,<span class="pl-pds">'</span></span>) {
    <span class="pl-c"><span class="pl-c">//</span> unexpected delimiter</span>
  }
  answer = fast_float::from_chars(answer.ptr + <span class="pl-c1">1</span>, input.data() + input.size(), result);
  <span class="pl-k">if</span> (answer.ec != std::errc()) {
    <span class="pl-c"><span class="pl-c">//</span> check error</span>
  }
  <span class="pl-c"><span class="pl-c">//</span> we have result == 7869234.9823.</span>
  <span class="pl-k">if</span> (answer.ptr[<span class="pl-c1">0</span>] != <span class="pl-s"><span class="pl-pds">'</span>,<span class="pl-pds">'</span></span>) {
    <span class="pl-c"><span class="pl-c">//</span> unexpected delimiter</span>
  }
  answer = fast_float::from_chars(answer.ptr + <span class="pl-c1">1</span>, input.data() + input.size(), result);
  <span class="pl-k">if</span> (answer.ec != std::errc()) {
    <span class="pl-c"><span class="pl-c">//</span> check error</span>
  }
  <span class="pl-c"><span class="pl-c">//</span> we have result == 324562.645.</span></pre></div>
<p dir="auto">Like the C++17 standard, the <code>fast_float::from_chars</code> functions take an optional
last argument of the type <code>fast_float::chars_format</code>. It is a bitset value: we
check whether <code>fmt &amp; fast_float::chars_format::fixed</code> and <code>fmt &amp; fast_float::chars_format::scientific</code> are set to determine whether we allow the
fixed point and scientific notation respectively. The default is
<code>fast_float::chars_format::general</code> which allows both <code>fixed</code> and <code>scientific</code>.</p>
<p dir="auto">The library seeks to follow the C++17 (see
<a href="https://eel.is/c++draft/charconv.from.chars#6.1" rel="nofollow">28.2.3.(6.1)</a>) specification.</p>
<ul dir="auto">
<li>The <code>from_chars</code> function does not skip leading white-space characters (unless
<code>fast_float::chars_format::skip_white_space</code> is set).</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/from_chars" rel="nofollow">A leading <code>+</code> sign</a> is
forbidden (unless <code>fast_float::chars_format::allow_leading_plus</code> is set).</li>
<li>It is generally impossible to represent a decimal value exactly as binary
floating-point number (<code>float</code> and <code>double</code> types). We seek the nearest value.
We round to an even mantissa when we are in-between two binary floating-point
numbers.</li>
</ul>
<p dir="auto">Furthermore, we have the following restrictions:</p>
<ul dir="auto">
<li>We support <code>float</code> and <code>double</code>, but not <code>long double</code>. We also support
fixed-width floating-point types such as <code>std::float64_t</code>, <code>std::float32_t</code>,
<code>std::float16_t</code>, and <code>std::bfloat16_t</code>.</li>
<li>We only support the decimal format: we do not support hexadecimal strings.</li>
<li>For values that are either very large or very small (e.g., <code>1e9999</code>), we
represent it using the infinity or negative infinity value and the returned
<code>ec</code> is set to <code>std::errc::result_out_of_range</code>.</li>
</ul>
<p dir="auto">We support Visual Studio, macOS, Linux, freeBSD. We support big and little
endian. We support 32-bit and 64-bit systems.</p>
<p dir="auto">We assume that the rounding mode is set to nearest (<code>std::fegetround() == FE_TONEAREST</code>).</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Integer types</h2><a id="user-content-integer-types" class="anchor" aria-label="Permalink: Integer types" href="#integer-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can also parse integer types using different bases (e.g., 2, 10, 16). The
following code will print the number 22250738585072012 three times:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  uint64_t i;
  std::string str = &quot;22250738585072012&quot;;
  auto answer = fast_float::from_chars(str.data(), str.data() + str.size(), i);
  if (answer.ec != std::errc()) {
    std::cerr &lt;&lt; &quot;parsing failure\n&quot;;
    return EXIT_FAILURE;
  }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; i &lt;&lt; std::endl;

  std::string binstr = &quot;1001111000011001110110111001001010110100111000110001100&quot;;

  answer = fast_float::from_chars(binstr.data(), binstr.data() + binstr.size(), i, 2);
  if (answer.ec != std::errc()) {
    std::cerr &lt;&lt; &quot;parsing failure\n&quot;;
    return EXIT_FAILURE;
  }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; i &lt;&lt; std::endl;

  std::string hexstr = &quot;4f0cedc95a718c&quot;;

  answer = fast_float::from_chars(hexstr.data(), hexstr.data() + hexstr.size(), i, 16);
  if (answer.ec != std::errc()) {
    std::cerr &lt;&lt; &quot;parsing failure\n&quot;;
    return EXIT_FAILURE;
  }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; i &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  <span class="pl-c1">uint64_t</span> i;
  std::string str = <span class="pl-s"><span class="pl-pds">"</span>22250738585072012<span class="pl-pds">"</span></span>;
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars</span>(str.<span class="pl-c1">data</span>(), str.<span class="pl-c1">data</span>() + str.<span class="pl-c1">size</span>(), i);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) {
    std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
    <span class="pl-k">return</span> EXIT_FAILURE;
  }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; i &lt;&lt; std::endl;

  std::string binstr = <span class="pl-s"><span class="pl-pds">"</span>1001111000011001110110111001001010110100111000110001100<span class="pl-pds">"</span></span>;

  answer = <span class="pl-c1">fast_float::from_chars</span>(binstr.<span class="pl-c1">data</span>(), binstr.<span class="pl-c1">data</span>() + binstr.<span class="pl-c1">size</span>(), i, <span class="pl-c1">2</span>);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) {
    std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
    <span class="pl-k">return</span> EXIT_FAILURE;
  }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; i &lt;&lt; std::endl;

  std::string hexstr = <span class="pl-s"><span class="pl-pds">"</span>4f0cedc95a718c<span class="pl-pds">"</span></span>;

  answer = <span class="pl-c1">fast_float::from_chars</span>(hexstr.<span class="pl-c1">data</span>(), hexstr.<span class="pl-c1">data</span>() + hexstr.<span class="pl-c1">size</span>(), i, <span class="pl-c1">16</span>);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) {
    std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
    <span class="pl-k">return</span> EXIT_FAILURE;
  }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; i &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Behavior of result_out_of_range</h2><a id="user-content-behavior-of-result_out_of_range" class="anchor" aria-label="Permalink: Behavior of result_out_of_range" href="#behavior-of-result_out_of_range"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When parsing floating-point values, the numbers can sometimes be too small
(e.g., <code>1e-1000</code>) or too large (e.g., <code>1e1000</code>). The C language established the
precedent that these small values are out of range. In such cases, it is
customary to parse small values to zero and large values to infinity. That is
the behaviour of the C language (e.g., <code>stdtod</code>). That is the behaviour followed
by the fast_float library.</p>
<p dir="auto">Specifically, we follow Jonathan Wakely's interpretation of the standard:</p>
<blockquote>
<p dir="auto">In any case, the resulting value is one of at most two floating-point values
closest to the value of the string matching the pattern.</p>
</blockquote>
<p dir="auto">It is also the approach taken by the <a href="https://github.com/microsoft/STL/blob/62205ab155d093e71dd9588a78f02c5396c3c14b/tests/std/tests/P0067R5_charconv/test.cpp#L943-L946">Microsoft C++
library</a>.</p>
<p dir="auto">Hence, we have the following examples:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  double result = -1;
  std::string str = &quot;3e-1000&quot;;
  auto r = fast_float::from_chars(str.data(), str.data() + str.size(), result);
  // r.ec == std::errc::result_out_of_range
  // r.ptr == str.data() + 7
  // result == 0"><pre>  <span class="pl-k">double</span> result = -<span class="pl-c1">1</span>;
  std::string str = <span class="pl-s"><span class="pl-pds">"</span>3e-1000<span class="pl-pds">"</span></span>;
  <span class="pl-k">auto</span> r = fast_float::from_chars(str.data(), str.data() + str.size(), result);
  <span class="pl-c"><span class="pl-c">//</span> r.ec == std::errc::result_out_of_range</span>
  <span class="pl-c"><span class="pl-c">//</span> r.ptr == str.data() + 7</span>
  <span class="pl-c"><span class="pl-c">//</span> result == 0</span></pre></div>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  double result = -1;
  std::string str = &quot;3e1000&quot;;
  auto r = fast_float::from_chars(str.data(), str.data() + str.size(), result);
  // r.ec == std::errc::result_out_of_range
  // r.ptr == str.data() + 6
  // result == std::numeric_limits&lt;double&gt;::infinity()"><pre>  <span class="pl-k">double</span> result = -<span class="pl-c1">1</span>;
  std::string str = <span class="pl-s"><span class="pl-pds">"</span>3e1000<span class="pl-pds">"</span></span>;
  <span class="pl-k">auto</span> r = fast_float::from_chars(str.data(), str.data() + str.size(), result);
  <span class="pl-c"><span class="pl-c">//</span> r.ec == std::errc::result_out_of_range</span>
  <span class="pl-c"><span class="pl-c">//</span> r.ptr == str.data() + 6</span>
  <span class="pl-c"><span class="pl-c">//</span> result == std::numeric_limits&lt;double&gt;::infinity()</span></pre></div>
<p dir="auto">Users who wish for the value to be left unmodified given
<code>std::errc::result_out_of_range</code> may do so by adding two lines of code:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  double old_result = result; // make copy
  auto r = fast_float::from_chars(start, end, result);
  if (r.ec == std::errc::result_out_of_range) { result = old_result; }"><pre>  <span class="pl-k">double</span> old_result = result; <span class="pl-c"><span class="pl-c">//</span> make copy</span>
  <span class="pl-k">auto</span> r = fast_float::from_chars(start, end, result);
  <span class="pl-k">if</span> (r.ec == std::errc::result_out_of_range) { result = old_result; }</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">C++20: compile-time evaluation (constexpr)</h2><a id="user-content-c20-compile-time-evaluation-constexpr" class="anchor" aria-label="Permalink: C++20: compile-time evaluation (constexpr)" href="#c20-compile-time-evaluation-constexpr"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In C++20, you may use <code>fast_float::from_chars</code> to parse strings at compile-time,
as in the following example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="// consteval forces compile-time evaluation of the function in C++20.
consteval double parse(std::string_view input) {
  double result;
  auto answer = fast_float::from_chars(input.data(), input.data() + input.size(), result);
  if (answer.ec != std::errc()) { return -1.0; }
  return result;
}

// This function should compile to a function which
// merely returns 3.1415.
constexpr double constexptest() {
  return parse(&quot;3.1415 input&quot;);
}"><pre><span class="pl-c"><span class="pl-c">//</span> consteval forces compile-time evaluation of the function in C++20.</span>
<span class="pl-k">consteval</span> <span class="pl-k">double</span> <span class="pl-en">parse</span>(std::string_view input) {
  <span class="pl-k">double</span> result;
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) { <span class="pl-k">return</span> -<span class="pl-c1">1.0</span>; }
  <span class="pl-k">return</span> result;
}

<span class="pl-c"><span class="pl-c">//</span> This function should compile to a function which</span>
<span class="pl-c"><span class="pl-c">//</span> merely returns 3.1415.</span>
<span class="pl-k">constexpr</span> <span class="pl-k">double</span> <span class="pl-en">constexptest</span>() {
  <span class="pl-k">return</span> <span class="pl-c1">parse</span>(<span class="pl-s"><span class="pl-pds">"</span>3.1415 input<span class="pl-pds">"</span></span>);
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">C++23: Fixed width floating-point types</h2><a id="user-content-c23-fixed-width-floating-point-types" class="anchor" aria-label="Permalink: C++23: Fixed width floating-point types" href="#c23-fixed-width-floating-point-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library also supports fixed-width floating-point types such as
<code>std::float64_t</code>, <code>std::float32_t</code>, <code>std::float16_t</code>, and <code>std::bfloat16_t</code>.
E.g., you can write:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="std::float32_t result;
auto answer = fast_float::from_chars(f.data(), f.data() + f.size(), result);"><pre>std::<span class="pl-k">float32_t</span> result;
<span class="pl-k">auto</span> answer = fast_float::from_chars(f.data(), f.data() + f.size(), result);</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Non-ASCII Inputs</h2><a id="user-content-non-ascii-inputs" class="anchor" aria-label="Permalink: Non-ASCII Inputs" href="#non-ascii-inputs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We also support UTF-16 and UTF-32 inputs, as well as ASCII/UTF-8, as in the
following example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::u16string input = u&quot;3.1416 xyz &quot;;
  double result;
  auto answer = fast_float::from_chars(input.data(), input.data() + input.size(), result);
  if (answer.ec != std::errc()) { std::cerr &lt;&lt; &quot;parsing failure\n&quot;; return EXIT_FAILURE; }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; result &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::u16string input = <span class="pl-s"><span class="pl-pds">u"</span>3.1416 xyz <span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Advanced options: using commas as decimal separator, JSON and Fortran</h2><a id="user-content-advanced-options-using-commas-as-decimal-separator-json-and-fortran" class="anchor" aria-label="Permalink: Advanced options: using commas as decimal separator, JSON and Fortran" href="#advanced-options-using-commas-as-decimal-separator-json-and-fortran"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The C++ standard stipulate that <code>from_chars</code> has to be locale-independent. In
particular, the decimal separator has to be the period (<code>.</code>). However, some
users still want to use the <code>fast_float</code> library with in a locale-dependent
manner. Using a separate function called <code>from_chars_advanced</code>, we allow the
users to pass a <code>parse_options</code> instance which contains a custom decimal
separator (e.g., the comma). You may use it as follows.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::string input = &quot;3,1416 xyz &quot;;
  double result;
  fast_float::parse_options options{fast_float::chars_format::general, ','};
  auto answer = fast_float::from_chars_advanced(input.data(), input.data() + input.size(), result, options);
  if ((answer.ec != std::errc()) || ((result != 3.1416))) { std::cerr &lt;&lt; &quot;parsing failure\n&quot;; return EXIT_FAILURE; }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; result &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>3,1416 xyz <span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  fast_float::parse_options options{fast_float::chars_format::general, <span class="pl-s"><span class="pl-pds">'</span>,<span class="pl-pds">'</span></span>};
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars_advanced</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result, options);
  <span class="pl-k">if</span> ((answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) || ((result != <span class="pl-c1">3.1416</span>))) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">You can also parse Fortran-like inputs</h3><a id="user-content-you-can-also-parse-fortran-like-inputs" class="anchor" aria-label="Permalink: You can also parse Fortran-like inputs" href="#you-can-also-parse-fortran-like-inputs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::string input = &quot;1d+4&quot;;
  double result;
  fast_float::parse_options options{fast_float::chars_format::fortran};
  auto answer = fast_float::from_chars_advanced(input.data(), input.data() + input.size(), result, options);
  if ((answer.ec != std::errc()) || ((result != 10000))) { std::cerr &lt;&lt; &quot;parsing failure\n&quot;; return EXIT_FAILURE; }
  std::cout &lt;&lt; &quot;parsed the number &quot; &lt;&lt; result &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>1d+4<span class="pl-pds">"</span></span>;
  <span class="pl-k">double</span> result;
  fast_float::parse_options options{fast_float::chars_format::fortran};
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars_advanced</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result, options);
  <span class="pl-k">if</span> ((answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>()) || ((result != <span class="pl-c1">10000</span>))) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsing failure<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>parsed the number <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">You may also enforce the JSON format (<a href="https://datatracker.ietf.org/doc/html/rfc8259#section-6" rel="nofollow">RFC 8259</a>)</h3><a id="user-content-you-may-also-enforce-the-json-format-rfc-8259" class="anchor" aria-label="Permalink: You may also enforce the JSON format (RFC 8259)" href="#you-may-also-enforce-the-json-format-rfc-8259"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::string input = &quot;+.1&quot;; // not valid
  double result;
  fast_float::parse_options options{fast_float::chars_format::json};
  auto answer = fast_float::from_chars_advanced(input.data(), input.data() + input.size(), result, options);
  if (answer.ec == std::errc()) { std::cerr &lt;&lt; &quot;should have failed\n&quot;; return EXIT_FAILURE; }
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>+.1<span class="pl-pds">"</span></span>; <span class="pl-c"><span class="pl-c">//</span> not valid</span>
  <span class="pl-k">double</span> result;
  fast_float::parse_options options{fast_float::chars_format::json};
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars_advanced</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result, options);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> == <span class="pl-c1">std::errc</span>()) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>should have failed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<p dir="auto">By default the JSON format does not allow <code>inf</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::string input = &quot;inf&quot;; // not valid in JSON
  double result;
  fast_float::parse_options options{fast_float::chars_format::json};
  auto answer = fast_float::from_chars_advanced(input.data(), input.data() + input.size(), result, options);
  if (answer.ec == std::errc()) { std::cerr &lt;&lt; &quot;should have failed\n&quot;; return EXIT_FAILURE; }
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>inf<span class="pl-pds">"</span></span>; <span class="pl-c"><span class="pl-c">//</span> not valid in JSON</span>
  <span class="pl-k">double</span> result;
  fast_float::parse_options options{fast_float::chars_format::json};
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars_advanced</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result, options);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> == <span class="pl-c1">std::errc</span>()) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>should have failed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<p dir="auto">You can allow it with a non-standard <code>json_or_infnan</code> variant:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;fast_float/fast_float.h&quot;
#include &lt;iostream&gt;

int main() {
  std::string input = &quot;inf&quot;; // not valid in JSON but we allow it with json_or_infnan
  double result;
  fast_float::parse_options options{fast_float::chars_format::json_or_infnan};
  auto answer = fast_float::from_chars_advanced(input.data(), input.data() + input.size(), result, options);
  if (answer.ec != std::errc() || (!std::isinf(result))) { std::cerr &lt;&lt; &quot;should have parsed infinity\n&quot;; return EXIT_FAILURE; }
  return EXIT_SUCCESS;
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>fast_float/fast_float.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  std::string input = <span class="pl-s"><span class="pl-pds">"</span>inf<span class="pl-pds">"</span></span>; <span class="pl-c"><span class="pl-c">//</span> not valid in JSON but we allow it with json_or_infnan</span>
  <span class="pl-k">double</span> result;
  fast_float::parse_options options{fast_float::chars_format::json_or_infnan};
  <span class="pl-k">auto</span> answer = <span class="pl-c1">fast_float::from_chars_advanced</span>(input.<span class="pl-c1">data</span>(), input.<span class="pl-c1">data</span>() + input.<span class="pl-c1">size</span>(), result, options);
  <span class="pl-k">if</span> (answer.<span class="pl-smi">ec</span> != <span class="pl-c1">std::errc</span>() || (!<span class="pl-c1">std::isinf</span>(result))) { std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>should have parsed infinity<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>; <span class="pl-k">return</span> EXIT_FAILURE; }
  <span class="pl-k">return</span> EXIT_SUCCESS;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Multiplication of an integer by a power of 10</h2><a id="user-content-multiplication-of-an-integer-by-a-power-of-10" class="anchor" aria-label="Permalink: Multiplication of an integer by a power of 10" href="#multiplication-of-an-integer-by-a-power-of-10"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">An integer <code>W</code> can be multiplied by a power of ten <code>10^Q</code> and
converted to <code>double</code> with correctly rounded value
(in "round to nearest, tie to even" fashion) using
<code>fast_float::integer_times_pow10()</code>, e.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const uint64_t W = 12345678901234567;
const int Q = 23;
const double result = fast_float::integer_times_pow10(W, Q);
std::cout.precision(17);
std::cout &lt;&lt; W &lt;&lt; &quot; * 10^&quot; &lt;&lt; Q &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; &quot; (&quot;
  &lt;&lt; (result == 12345678901234567e23 ? &quot;==&quot; : &quot;!=&quot;) &lt;&lt; &quot;expected)\n&quot;;"><pre><span class="pl-k">const</span> <span class="pl-c1">uint64_t</span> W = <span class="pl-c1">12345678901234567</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> Q = <span class="pl-c1">23</span>;
<span class="pl-k">const</span> <span class="pl-k">double</span> result = fast_float::integer_times_pow10(W, Q);
std::cout.precision(<span class="pl-c1">17</span>);
std::cout &lt;&lt; W &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> * 10^<span class="pl-pds">"</span></span> &lt;&lt; Q &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> (<span class="pl-pds">"</span></span>
  &lt;&lt; (result == <span class="pl-c1">12345678901234567e23</span> ? <span class="pl-s"><span class="pl-pds">"</span>==<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>!=<span class="pl-pds">"</span></span>) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>expected)<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;</pre></div>
<p dir="auto">outputs</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="12345678901234567 * 10^23 = 1.2345678901234567e+39 (==expected)"><pre class="notranslate"><code>12345678901234567 * 10^23 = 1.2345678901234567e+39 (==expected)
</code></pre></div>
<p dir="auto"><code>fast_float::integer_times_pow10()</code> gives the same result as
using <code>fast_float::from_chars()</code> when parsing the string <code>"WeQ"</code>
(in this example <code>"12345678901234567e23"</code>),
except <code>fast_float::integer_times_pow10()</code> does not report out-of-range errors, and
underflows to zero or overflows to infinity when the resulting value is
out of range.</p>
<p dir="auto">Overloads of <code>fast_float::integer_times_pow10()</code> are provided for
signed and unsigned integer types: <code>int64_t</code>, <code>uint64_t</code>, etc.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Users and Related Work</h2><a id="user-content-users-and-related-work" class="anchor" aria-label="Permalink: Users and Related Work" href="#users-and-related-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The fast_float library is part of:</p>
<ul dir="auto">
<li>GCC (as of version 12): the <code>from_chars</code> function in GCC relies on fast_float,</li>
<li><a href="https://github.com/Chromium/Chromium">Chromium</a>, the engine behind Google
Chrome, Microsoft Edge, and Opera,</li>
<li>Boost JSON, MySQL, etc.</li>
<li>Blender</li>
<li><a href="https://github.com/WebKit/WebKit">WebKit</a>, the engine behind Safari (Apple's
web browser),</li>
<li><a href="https://duckdb.org" rel="nofollow">DuckDB</a>,</li>
<li><a href="https://github.com/redis/redis">Redis</a> and <a href="https://github.com/valkey-io/valkey">Valkey</a>,</li>
<li><a href="https://github.com/apache/arrow/pull/8494" data-hovercard-type="pull_request" data-hovercard-url="/apache/arrow/pull/8494/hovercard">Apache Arrow</a> where it multiplied
the number parsing speed by two or three times,</li>
<li><a href="https://github.com/google/jsonnet">Google Jsonnet</a>,</li>
<li><a href="https://github.com/ClickHouse/ClickHouse">ClickHouse</a>.</li>
</ul>
<p dir="auto">The fastfloat algorithm is part of the <a href="https://github.com/llvm/llvm-project/commit/87c016078ad72c46505461e4ff8bfa04819fe7ba">LLVM standard
libraries</a>.
There is a <a href="https://github.com/AdaCore/VSS">derived implementation part of
AdaCore</a>. The <a href="https://github.com/SerenityOS/serenity/commit/53b7f5e6a11e663c83df8030c3171c5945cb75ec">SerenityOS operating
system</a>
has a derived implementation that is inherited by the <a href="https://github.com/LadybirdBrowser/ladybird">Ladybird
Browser</a>.</p>
<p dir="auto">The fast_float library provides a performance similar to that of the
<a href="https://github.com/lemire/fast_double_parser">fast_double_parser</a> library but
using an updated algorithm reworked from the ground up, and while offering an
API more in line with the expectations of C++ programmers. The
fast_double_parser library is part of the <a href="https://github.com/microsoft/LightGBM">Microsoft LightGBM machine-learning
framework</a>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Packages</h2><a id="user-content-packages" class="anchor" aria-label="Permalink: Packages" href="#packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://repology.org/project/fastfloat/versions" rel="nofollow"><img src="https://camo.githubusercontent.com/a8436dfba2f0d16699b7007ba6e9ac185170e2b20bb21dbfa122c23cf6bb40c6/68747470733a2f2f7265706f6c6f67792e6f72672f62616467652f766572746963616c2d616c6c7265706f732f66617374666c6f61742e737667" alt="Packaging status" data-canonical-src="https://repology.org/badge/vertical-allrepos/fastfloat.svg" style="max-width: 100%;"></a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">References</h2><a id="user-content-references" class="anchor" aria-label="Permalink: References" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Daniel Lemire, <a href="https://arxiv.org/abs/2101.11408" rel="nofollow">Number Parsing at a Gigabyte per
Second</a>, Software: Practice and Experience
51 (8), 2021.</li>
<li>Noble Mushtak, Daniel Lemire, <a href="https://arxiv.org/abs/2212.06644" rel="nofollow">Fast Number Parsing Without
Fallback</a>, Software: Practice and Experience
53 (7), 2023.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Other programming languages</h2><a id="user-content-other-programming-languages" class="anchor" aria-label="Permalink: Other programming languages" href="#other-programming-languages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="https://github.com/eddelbuettel/rcppfastfloat">There is an R binding</a> called
<code>rcppfastfloat</code>.</li>
<li><a href="https://github.com/aldanor/fast-float-rust/">There is a Rust port of the fast_float
library</a> called
<code>fast-float-rust</code>.</li>
<li><a href="https://github.com/wrandelshofer/FastDoubleParser">There is a Java port of the fast_float
library</a> called
<code>FastDoubleParser</code>. It used for important systems such as
<a href="https://github.com/FasterXML/jackson-core">Jackson</a>.</li>
<li><a href="https://github.com/CarlVerret/csFastFloat">There is a C# port of the fast_float
library</a> called <code>csFastFloat</code>.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">How fast is it?</h2><a id="user-content-how-fast-is-it" class="anchor" aria-label="Permalink: How fast is it?" href="#how-fast-is-it"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">It can parse random floating-point numbers at a speed of 1 GB/s on some systems.
We find that it is often twice as fast as the best available competitor, and
many times faster than many standard-library implementations.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d2f8921f6ef7856c291563a660d1b6835a26cfb40b026bea6ce01e13b72fcf43/68747470733a2f2f6c656d6972652e6d652f626c6f672f77702d636f6e74656e742f75706c6f6164732f323032302f31312f66617374666c6f61745f73706565642e706e67"><img src="https://camo.githubusercontent.com/d2f8921f6ef7856c291563a660d1b6835a26cfb40b026bea6ce01e13b72fcf43/68747470733a2f2f6c656d6972652e6d652f626c6f672f77702d636f6e74656e742f75706c6f6164732f323032302f31312f66617374666c6f61745f73706565642e706e67" width="400" alt="fast_float is many times faster than many standard-library
implementations" data-canonical-src="https://lemire.me/blog/wp-content/uploads/2020/11/fastfloat_speed.png" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ ./build/benchmarks/benchmark
# parsing random integers in the range [0,1)
volume = 2.09808 MB
netlib                                  :   271.18 MB/s (+/- 1.2 %)    12.93 Mfloat/s
doubleconversion                        :   225.35 MB/s (+/- 1.2 %)    10.74 Mfloat/s
strtod                                  :   190.94 MB/s (+/- 1.6 %)     9.10 Mfloat/s
abseil                                  :   430.45 MB/s (+/- 2.2 %)    20.52 Mfloat/s
fastfloat                               :  1042.38 MB/s (+/- 9.9 %)    49.68 Mfloat/s"><pre>$ ./build/benchmarks/benchmark
<span class="pl-c"><span class="pl-c">#</span> parsing random integers in the range [0,1)</span>
volume = 2.09808 MB
netlib                                  <span class="pl-c1">:</span>   271.18 MB/s (+/- 1.2 %)    12.93 Mfloat/s
doubleconversion                        <span class="pl-c1">:</span>   225.35 MB/s (+/- 1.2 %)    10.74 Mfloat/s
strtod                                  <span class="pl-c1">:</span>   190.94 MB/s (+/- 1.6 %)     9.10 Mfloat/s
abseil                                  <span class="pl-c1">:</span>   430.45 MB/s (+/- 2.2 %)    20.52 Mfloat/s
fastfloat                               <span class="pl-c1">:</span>  1042.38 MB/s (+/- 9.9 %)    49.68 Mfloat/s</pre></div>
<p dir="auto">See the <a href="#benchmarking">Benchmarking</a> section for instructions on how to run our benchmarks.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Video</h2><a id="user-content-video" class="anchor" aria-label="Permalink: Video" href="#video"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://www.youtube.com/watch?v=AVXgvlMeIm4" rel="nofollow"><img src="https://camo.githubusercontent.com/4174287bf3cec3107b3cc3d48a2892b4b5300e615434e244be795cdabb1bc2fa/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f41565867766c4d65496d342f302e6a7067" alt="Go Systems 2020" data-canonical-src="https://img.youtube.com/vi/AVXgvlMeIm4/0.jpg" style="max-width: 100%;"></a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Using as a CMake dependency</h2><a id="user-content-using-as-a-cmake-dependency" class="anchor" aria-label="Permalink: Using as a CMake dependency" href="#using-as-a-cmake-dependency"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This library is header-only by design. The CMake file provides the <code>fast_float</code>
target which is merely a pointer to the <code>include</code> directory.</p>
<p dir="auto">If you drop the <code>fast_float</code> repository in your CMake project, you should be
able to use it in this manner:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add_subdirectory(fast_float)
target_link_libraries(myprogram PUBLIC fast_float)"><pre><span class="pl-c1">add_subdirectory</span>(<span class="pl-s">fast_float</span>)
<span class="pl-c1">target_link_libraries</span>(<span class="pl-s">myprogram</span> <span class="pl-c1">PUBLIC</span> <span class="pl-s">fast_float</span>)</pre></div>
<p dir="auto">Or you may want to retrieve the dependency automatically if you have a
sufficiently recent version of CMake (3.11 or better at least):</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FetchContent_Declare(
  fast_float
  GIT_REPOSITORY https://github.com/fastfloat/fast_float.git
  GIT_TAG tags/v8.1.0
  GIT_SHALLOW TRUE)

FetchContent_MakeAvailable(fast_float)
target_link_libraries(myprogram PUBLIC fast_float)"><pre><span class="pl-en">FetchContent_Declare</span>(
  <span class="pl-en">fast_float</span>
  <span class="pl-s">GIT_REPOSITORY</span> <span class="pl-s">https://github.com/fastfloat/fast_float.git</span>
  <span class="pl-s">GIT_TAG</span> <span class="pl-s">tags/v8.1.0</span>
  <span class="pl-s">GIT_SHALLOW</span> <span class="pl-c1">TRUE</span>)

<span class="pl-en">FetchContent_MakeAvailable</span>(<span class="pl-s">fast_float</span>)
<span class="pl-c1">target_link_libraries</span>(<span class="pl-s">myprogram</span> <span class="pl-c1">PUBLIC</span> <span class="pl-s">fast_float</span>)</pre></div>
<p dir="auto">You should change the <code>GIT_TAG</code> line so that you recover the version you wish to
use.</p>
<p dir="auto">You may also use <a href="https://github.com/cpm-cmake/CPM.cmake">CPM</a>, like so:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPMAddPackage(
  NAME fast_float
  GITHUB_REPOSITORY &quot;fastfloat/fast_float&quot;
  GIT_TAG v8.1.0)"><pre><span class="pl-en">CPMAddPackage</span>(
  <span class="pl-c1">NAME</span> <span class="pl-en">fast_float</span>
  <span class="pl-s">GITHUB_REPOSITORY</span> <span class="pl-s">"fastfloat/fast_float"</span>
  <span class="pl-s">GIT_TAG</span> <span class="pl-s">v8.1.0</span>)</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Using as single header</h2><a id="user-content-using-as-single-header" class="anchor" aria-label="Permalink: Using as single header" href="#using-as-single-header"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The script <code>script/amalgamate.py</code> may be used to generate a single header
version of the library if so desired. Just run the script from the root
directory of this repository. You can customize the license type and output file
if desired as described in the command line help.</p>
<p dir="auto">You may directly download automatically generated single-header files:</p>
<p dir="auto"><a href="https://github.com/fastfloat/fast_float/releases/download/v8.1.0/fast_float.h">https://github.com/fastfloat/fast_float/releases/download/v8.1.0/fast_float.h</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Benchmarking</h2><a id="user-content-benchmarking" class="anchor" aria-label="Permalink: Benchmarking" href="#benchmarking"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The project has its own benchmarks with realistic data inputs. Under Linux or macOS,
you can use it as follows if your system supports C++17:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build -D FASTFLOAT_BENCHMARKS=ON
cmake --build build
./build/benchmarks/realbenchmark"><pre class="notranslate"><code>cmake -B build -D FASTFLOAT_BENCHMARKS=ON
cmake --build build
./build/benchmarks/realbenchmark
</code></pre></div>
<p dir="auto">Importantly, by default, the benchmark is built in Release mode.</p>
<p dir="auto">The instructions are similar under Windows.</p>
<p dir="auto">Under Linux and macOS, it is recommended to run the benchmarks in a privileged manner to get access
to hardware performance counters. You may be able to do so with the <code>sudo</code> command
in some cases:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="sudo ./build/benchmarks/realbenchmark"><pre class="notranslate"><code>sudo ./build/benchmarks/realbenchmark
</code></pre></div>
<p dir="auto">If you have a text file containing one number per line (<code>myfile.txt</code>), you can run a benchmark over it like so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cmake -B build -D FASTFLOAT_BENCHMARKS=ON
cmake --build build
./build/benchmarks/realbenchmark myfile.txt"><pre class="notranslate"><code>cmake -B build -D FASTFLOAT_BENCHMARKS=ON
cmake --build build
./build/benchmarks/realbenchmark myfile.txt
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Packages</h2><a id="user-content-packages-1" class="anchor" aria-label="Permalink: Packages" href="#packages-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>The fast_float library is part of the <a href="https://conan.io/center/recipes/fast_float" rel="nofollow">Conan package
manager</a>.</li>
<li>It is part of the <a href="https://formulae.brew.sh/formula/fast_float" rel="nofollow">brew package
manager</a>.</li>
<li>fast_float is available on <a href="https://xmake.io" rel="nofollow">xmake</a> repository.</li>
<li>Some Linux distribution like Fedora include fast_float (e.g., as
<code>fast_float-devel</code>).</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Credit</h2><a id="user-content-credit" class="anchor" aria-label="Permalink: Credit" href="#credit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Though this work is inspired by many different people, this work benefited
especially from exchanges with Michael Eisel, who motivated the original
research with his key insights, and with Nigel Tao who provided invaluable
feedback. Rémy Oudompheng first implemented a fast path we use in the case of
long digits.</p>
<p dir="auto">The library includes code adapted from Google Wuffs (written by Nigel Tao) which
was originally published under the Apache 2.0 license.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">License</h2><a id="user-content-license" class="anchor" aria-label="Permalink: License" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<sup>
Licensed under either of <a href="LICENSE-APACHE">Apache License, Version
2.0</a> or <a href="LICENSE-MIT">MIT license</a> or <a href="LICENSE-BOOST">BOOST license</a>.
</sup>
<br>
<sub>
Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in this repository by you, as defined in the Apache-2.0 license,
shall be triple licensed as above, without any additional terms or conditions.
</sub>
</article></div>