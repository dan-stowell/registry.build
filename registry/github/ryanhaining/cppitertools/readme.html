<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">CPPItertools</h1><a id="user-content-cppitertools" class="anchor" aria-label="Permalink: CPPItertools" href="#cppitertools"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Range-based for loop add-ons inspired by the Python builtins and itertools
library.  Like itertools and the Python3 builtins, this library uses lazy
evaluation wherever possible.</p>
<p dir="auto"><em>Note</em>: Everything is inside the <code>iter</code> namespace.</p>
<p dir="auto">Follow <a href="https://twitter.com/cppitertools" rel="nofollow">@cppitertools</a> for updates.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Build and Test Status</h4><a id="user-content-build-and-test-status" class="anchor" aria-label="Permalink: Build and Test Status" href="#build-and-test-status"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Status</th>
<th>Compilers</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://app.travis-ci.com/github/ryanhaining/cppitertools" rel="nofollow"><img src="https://camo.githubusercontent.com/4c220c245f3d6174d10327af652ced5cb19cf456a12dbf538b9b7b3e59383e1e/68747470733a2f2f7472617669732d63692e636f6d2f7279616e6861696e696e672f63707069746572746f6f6c732e7376673f6272616e63683d6d6173746572" alt="Travis Build Status" data-canonical-src="https://travis-ci.com/ryanhaining/cppitertools.svg?branch=master" style="max-width: 100%;"></a></td>
<td>gcc-7 gcc-8 gcc-9 clang-5.0 clang-6.0 clang-7 clang-8 clang-9</td>
</tr>
<tr>
<td><a href="https://ci.appveyor.com/project/ryanhaining/cppitertools" rel="nofollow"><img src="https://camo.githubusercontent.com/c06e6b09ed2dec8ebbe2f864d8fab22befdcd04a26672e159795ea6a1bbb1784/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f7279616e6861696e696e672f63707069746572746f6f6c733f7376673d74727565" alt="Appveyor Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/ryanhaining/cppitertools?svg=true" style="max-width: 100%;"></a></td>
<td>MSVC 2017 MSVC 2019</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Table of Contents</h4><a id="user-content-table-of-contents" class="anchor" aria-label="Permalink: Table of Contents" href="#table-of-contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="#range">range</a><br>
<a href="#enumerate">enumerate</a><br>
<a href="#zip">zip</a><br>
<a href="#zip">zip_longest</a><br>
<a href="#imap">imap</a><br>
<a href="#filter">filter</a><br>
<a href="#filterfalse">filterfalse</a><br>
<a href="#unique_everseen">unique_everseen</a><br>
<a href="#unique_justseen">unique_justseen</a><br>
<a href="#takewhile">takewhile</a><br>
<a href="#dropwhile">dropwhile</a><br>
<a href="#cycle">cycle</a><br>
<a href="#repeat">repeat</a><br>
<a href="#count">count</a><br>
<a href="#groupby">groupby</a><br>
<a href="#starmap">starmap</a><br>
<a href="#accumulate">accumulate</a><br>
<a href="#compress">compress</a><br>
<a href="#sorted">sorted</a><br>
<a href="#chain">chain</a><br>
<a href="#chainfrom_iterable">chain.from_iterable</a><br>
<a href="#reversed">reversed</a><br>
<a href="#slice">slice</a><br>
<a href="#sliding_window">sliding_window</a><br>
<a href="#chunked">chunked</a><br>
<a href="#batched">batched</a><br></p>
<div class="markdown-heading" dir="auto"><h5 class="heading-element" dir="auto">Combinatoric fuctions</h5><a id="user-content-combinatoric-fuctions" class="anchor" aria-label="Permalink: Combinatoric fuctions" href="#combinatoric-fuctions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="#product">product</a><br>
<a href="#combinations">combinations</a><br>
<a href="#combinations_with_replacement">combinations_with_replacement</a><br>
<a href="#permutations">permutations</a><br>
<a href="#powerset">powerset</a><br></p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Requirements</h4><a id="user-content-requirements" class="anchor" aria-label="Permalink: Requirements" href="#requirements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This library is <strong>header-only</strong> and relies only on the C++ standard
library. The only exception is <code>zip_longest</code> which uses <code>boost::optional</code>.
<code>#include &lt;cppitertools/itertools.hpp&gt;</code> will include all of the provided
tools except for <code>zip_longest</code> which must be included separately.  You may
also include individual pieces with the relevant header
(<code>#include &lt;cppitertools/enumerate.hpp&gt;</code> for example).</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Running tests</h3><a id="user-content-running-tests" class="anchor" aria-label="Permalink: Running tests" href="#running-tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You may use either <code>scons</code> or <code>bazel</code> to build the tests. <code>scons</code> seems
to work better with viewing the test output, but the same <code>bazel</code> command
can be run from any directory.</p>
<p dir="auto">To run tests with scons you must be within the <code>test</code> directory</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="test$ # build and run all tests
test$ scons
test$ ./test_all
test$ # build and run a specific test
test$ scons test_enumerate
test$ ./test_enumerate
test$ valgrind ./test_enumerate"><pre>test$ <span class="pl-c"><span class="pl-c">#</span> build and run all tests</span>
test$ scons
test$ ./test_all
test$ <span class="pl-c"><span class="pl-c">#</span> build and run a specific test</span>
test$ scons test_enumerate
test$ ./test_enumerate
test$ valgrind ./test_enumerate</pre></div>
<p dir="auto"><code>bazel</code> absolute commands can be run from any directory inside the project</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ bazel test //test:all # runs all tests
$ bazel test //test:test_enumerate # runs a specific test"><pre>$ bazel <span class="pl-c1">test</span> //test:all <span class="pl-c"><span class="pl-c">#</span> runs all tests</span>
$ bazel <span class="pl-c1">test</span> //test:test_enumerate <span class="pl-c"><span class="pl-c">#</span> runs a specific test</span></pre></div>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Requirements of passed objects</h4><a id="user-content-requirements-of-passed-objects" class="anchor" aria-label="Permalink: Requirements of passed objects" href="#requirements-of-passed-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Most itertools will work with iterables using InputIterators and not copy
or move any underlying elements.  The itertools that need ForwardIterators or
have additional requirements are noted in this document. However, the cases
should be fairly obvious: any time an element needs to appear multiple times
(as in <code>combinations</code> or <code>cycle</code>) or be looked at more than once (specifically,
<code>sorted</code>).
This library takes every effort to rely on as little as possible from the
underlying iterables, but if anything noteworthy is needed it is described
in this document.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Guarantees of implementations</h4><a id="user-content-guarantees-of-implementations" class="anchor" aria-label="Permalink: Guarantees of implementations" href="#guarantees-of-implementations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">By implementations, I mean the objects returned by the API's functions. All of
the implementation classes are move-constructible, not copy-constructible,
not assignable. All iterators that work over another iterable are tagged
as InputIterators and behave as such.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Feedback</h4><a id="user-content-feedback" class="anchor" aria-label="Permalink: Feedback" href="#feedback"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you find anything not working as you expect, not compiling when you believe
it should, a divergence from the python itertools behavior, or any sort of
error, please let me know. The preferable means would be to open an issue on
GitHub. If you want to talk about an issue that you don't feel would be
appropriate as a GitHub issue (or you just don't want to open one),
you can email me directly with whatever code you have that describes the
problem; I've been pretty responsive in the past. If I believe you are
"misusing" the library, I'll try to put the blame on myself for being unclear
in this document and take the steps to clarify it.  So please, contact me with
any concerns, I'm open to feedback.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">How (not) to use this library</h4><a id="user-content-how-not-to-use-this-library" class="anchor" aria-label="Permalink: How (not) to use this library" href="#how-not-to-use-this-library"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library functions create and return objects that are properly templated on
the iterable they are passed. These exact names of these types or
precisely how they are templated is unspecified, you should rely on the
functions described in this document.
If you plan to use these functions in very simple, straight forward means as in
the examples on this page, then you will be fine. If you feel like you need to
open the header files, then I've probably under-described something, let me
know.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Handling of rvalues vs lvalues</h4><a id="user-content-handling-of-rvalues-vs-lvalues" class="anchor" aria-label="Permalink: Handling of rvalues vs lvalues" href="#handling-of-rvalues-vs-lvalues"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The rules are pretty simple, and the library can be largely used without
knowledge of them.
Let's take an example</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="std::vector&lt;int&gt; vec{2,4,6,8};
for (auto&amp;&amp; p : enumerate(vec)) { /* ... */ }"><pre>std::vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">2</span>,<span class="pl-c1">4</span>,<span class="pl-c1">6</span>,<span class="pl-c1">8</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; p : enumerate(vec)) { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }</pre></div>
<p dir="auto">In this case, <code>enumerate</code> will return an object that has bound a reference to
<code>vec</code>. No copies are produced here, neither of <code>vec</code> nor of the elements it
holds.</p>
<p dir="auto">If an rvalue was passed to enumerate, binding a reference would be unsafe.
Consider:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; p : enumerate(std::vector&lt;int&gt;{2,4,6,8})) { /* ... */ }"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; p : enumerate(std::vector&lt;<span class="pl-k">int</span>&gt;{<span class="pl-c1">2</span>,<span class="pl-c1">4</span>,<span class="pl-c1">6</span>,<span class="pl-c1">8</span>})) { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }</pre></div>
<p dir="auto">Instead, <code>enumerate</code> will return an object that has the temporary <em>moved</em> into
it.  That is, the returned object will contain a <code>std::vector&lt;int&gt;</code> rather than
just a reference to one. This may seem like a contrived example, but it matters
when <code>enumerate</code> is passed the result of a function call like <code>enumerate(f())</code>,
or, more obviously, something like <code>enumerate(zip(a, b))</code>.  The object returned
from <code>zip</code> must be moved into the <code>enumerate</code> object. As a more specific
result, itertools can be mixed and nested.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">Pipe syntax</h4><a id="user-content-pipe-syntax" class="anchor" aria-label="Permalink: Pipe syntax" href="#pipe-syntax"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Wherever it makes sense, I've implemented the "pipe" operator that has become
common in similar libraries. When the syntax is available, it is done by pulling
out the iterable from the call and placing it before the tool. For example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filter(pred, seq);  // regular call
seq | filter(pred);  // pipe-style
enumerate(seq);  // regular call
seq | enumerate;  // pipe-style."><pre><span class="pl-en">filter</span>(pred, seq);  <span class="pl-c"><span class="pl-c">//</span> regular call</span>
seq | filter(pred);  <span class="pl-c"><span class="pl-c">//</span> pipe-style</span>
enumerate(seq);  <span class="pl-c"><span class="pl-c">//</span> regular call</span>
seq | enumerate;  <span class="pl-c"><span class="pl-c">//</span> pipe-style.</span></pre></div>
<p dir="auto">The following tools support pipe. The remaining I left out because although
some of them have multiple reasonable versions, it wasn't obvious to me how I
would expect them to behave:</p>
<ul dir="auto">
<li>accumulate</li>
<li>chain.from_iterable</li>
<li>chunked</li>
<li>batched</li>
<li>combinations</li>
<li>combinations_with_replacement</li>
<li>cycle</li>
<li>dropwhile</li>
<li>enumerate</li>
<li>filter</li>
<li>filterfalse</li>
<li>groupby</li>
<li>imap</li>
<li>permutations</li>
<li>powerset</li>
<li>reversed</li>
<li>slice</li>
<li>sliding_window</li>
<li>sorted</li>
<li>starmap</li>
<li>takewhile</li>
<li>unique_everseen (*only without custom hash and equality callables)</li>
<li>unique_justseen</li>
</ul>
<p dir="auto">I don't personally care for the piping style, but it seemed to be desired by
the users.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">range</h2><a id="user-content-range" class="anchor" aria-label="Permalink: range" href="#range"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Uses an underlying iterator to achieve the same effect of the python range
function.  <code>range</code> can be used in three different ways:</p>
<p dir="auto">Only the stopping point is provided.  Prints <code>0 1 2 3 4 5 6 7 8 9</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto i : range(10)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span> i : range(<span class="pl-c1">10</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">The start and stop are both provided.  Prints <code>10 11 12 13 14</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto i : range(10, 15)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span> i : range(<span class="pl-c1">10</span>, <span class="pl-c1">15</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">The start, stop, and step are all provided.  Prints <code>20 22 24 26 28</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto i : range(20, 30, 2)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span> i : range(<span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">2</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">Negative values are allowed as well.  Prints <code>2 1 0 -1 -2</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto i : range(2, -3, -1)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span> i : range(<span class="pl-c1">2</span>, -<span class="pl-c1">3</span>, -<span class="pl-c1">1</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">A step size of 0 results in an empty range (Python's raises an exception).
The following prints nothing</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto i : range(0, 10, 0)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span> i : range(<span class="pl-c1">0</span>, <span class="pl-c1">10</span>, <span class="pl-c1">0</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">In addition to normal integer range operations, doubles and
other numeric types are supported through the template</p>
<p dir="auto">Prints: <code>5.0 5.5 6.0</code> ... <code>9.5</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for(auto i : range(5.0, 10.0, 0.5)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span>(<span class="pl-k">auto</span> i : range(<span class="pl-c1">5.0</span>, <span class="pl-c1">10.0</span>, <span class="pl-c1">0.5</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto"><em>Implementation Note</em>: Typical ranges have their current value incremented by
the step size repeatedly (<code>value += step</code>). Floating point range value are
recomputed at each step to avoid accumulating floating point inaccuracies
(<code>value = start + (step * steps_taken</code>). The result of the latter is a bit
slower but more accurate.</p>
<p dir="auto"><code>range</code> also supports the following operations:</p>
<ul dir="auto">
<li><code>.size()</code> to get the number of elements in the range (not enabled for
floating point ranges).</li>
<li>Accessors for <code>.start()</code>, <code>.stop()</code>, and <code>.step()</code>.</li>
<li>Indexing. Given a range <code>r</code>, <code>r[n]</code> is the <code>n</code>th element in the range.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">enumerate</h2><a id="user-content-enumerate" class="anchor" aria-label="Permalink: enumerate" href="#enumerate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Continually "yields" containers similar to pairs.  They are structs with
the index in <code>.first</code>, and the element in <code>.second</code>, and also work with structured
binding declarations.
Usage appears as:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec{2, 4, 6, 8};
for (auto&amp;&amp; [i, e] : enumerate(vec)) {
    cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; e &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>, <span class="pl-c1">8</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; [i, e] : enumerate(vec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>: <span class="pl-pds">"</span></span> &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">filter</h2><a id="user-content-filter" class="anchor" aria-label="Permalink: filter" href="#filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Called as <code>filter(predicate, iterable)</code>.  The predicate can be any callable.
<code>filter</code> will only yield values that are true under the predicate.</p>
<p dir="auto">Prints values greater than 4:  <code>5 6 7 8</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec{1, 5, 4, 0, 6, 7, 3, 0, 2, 8, 3, 2, 1};
for (auto&amp;&amp; i : filter([] (int i) { return i &gt; 4; }, vec)) {
    cout &lt;&lt; i &lt;&lt;'\n';
}
"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">4</span>, <span class="pl-c1">0</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">8</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : filter([] (<span class="pl-k">int</span> i) { <span class="pl-k">return</span> i &gt; <span class="pl-c1">4</span>; }, vec)) {
    cout &lt;&lt; i &lt;&lt;<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}
</pre></div>
<p dir="auto">If no predicate is passed, the elements themselves are tested for truth</p>
<p dir="auto">Prints only non-zero values.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for(auto&amp;&amp; i : filter(vec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span>(<span class="pl-k">auto</span>&amp;&amp; i : filter(vec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">filterfalse</h2><a id="user-content-filterfalse" class="anchor" aria-label="Permalink: filterfalse" href="#filterfalse"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Similar to filter, but only prints values that are false under the predicate.</p>
<p dir="auto">Prints values not greater than 4: <code>1 4 3 2 3 2 1 </code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec{1, 5, 4, 0, 6, 7, 3, 0, 2, 8, 3, 2, 1};
for (auto&amp;&amp; i : filterfalse([] (int i) { return i &gt; 4; }, vec)) {
    cout &lt;&lt; i &lt;&lt;'\n';
}
"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">4</span>, <span class="pl-c1">0</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">8</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : filterfalse([] (<span class="pl-k">int</span> i) { <span class="pl-k">return</span> i &gt; <span class="pl-c1">4</span>; }, vec)) {
    cout &lt;&lt; i &lt;&lt;<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}
</pre></div>
<p dir="auto">If no predicate is passed, the elements themselves are tested for truth.</p>
<p dir="auto">Prints only zero values.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for(auto&amp;&amp; i : filterfalse(vec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}
"><pre><span class="pl-k">for</span>(<span class="pl-k">auto</span>&amp;&amp; i : filterfalse(vec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}
</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">unique_everseen</h2><a id="user-content-unique_everseen" class="anchor" aria-label="Permalink: unique_everseen" href="#unique_everseen"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Underlying values must be copy-constructible.</p>
<p dir="auto">This is a filter adaptor that only generates values that have never been seen
before.</p>
<p dir="auto">Prints <code>1 2 3 4 5 6 7 8 9</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v {1,2,3,4,3,2,1,5,6,7,7,8,9,8,9,6};
for (auto&amp;&amp; i : unique_everseen(v)) {
    cout &lt;&lt; i &lt;&lt; ' ';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">6</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : unique_everseen(v)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto"><code>unique_everseen</code> uses an <code>undordered_set</code> so it needs hashable elements. For
types that don't work with <code>std::hash</code> or <code>std::equal_to</code>, <code>unique_everseen</code>
also provides an overload taking a hash callable and an equality callable.
This <strong>does not</strong> work with the pipe syntax.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;Widget&gt; v { /* ... */ };
for (auto&amp;&amp; w : unique_everseen(v, WidgetHash{}, WidgetEq{})) {
  cout &lt;&lt; w.name() &lt;&lt; ' ';
}"><pre>vector&lt;Widget&gt; v { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> };
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; w : unique_everseen(v, WidgetHash{}, WidgetEq{})) {
  cout &lt;&lt; w.<span class="pl-c1">name</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">unique_justseen</h2><a id="user-content-unique_justseen" class="anchor" aria-label="Permalink: unique_justseen" href="#unique_justseen"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Another filter adaptor that only omits consecutive duplicates.</p>
<p dir="auto">Prints <code>1 2 3 4 3 2 1</code>
Example Usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v {1,1,1,2,2,3,3,3,4,3,2,1,1,1};
for (auto&amp;&amp; i : unique_justseen(v)) {
    cout &lt;&lt; i &lt;&lt; ' ';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v {<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : unique_justseen(v)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">If elements cannot be directly compared with equality, you can pass in a key
callable.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;Person&gt; v { /* ... */ };
for (auto&amp;&amp; p : unique_justseen(v, [] (const Person&amp; p) { return p.name; }))
  cout &lt;&lt; p.name() &lt;&lt; ' ' &lt;&lt; p.age() &lt;&lt; '\n';
}"><pre>vector&lt;Person&gt; v { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> };
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; p : unique_justseen(v, [] (<span class="pl-k">const</span> Person&amp; p) { <span class="pl-k">return</span> p.<span class="pl-smi">name</span>; }))
  cout &lt;&lt; p.name() &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &lt;&lt; p.age() &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">takewhile</h2><a id="user-content-takewhile" class="anchor" aria-label="Permalink: takewhile" href="#takewhile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Yields elements from an iterable until the first element that is false under
the predicate is encountered.</p>
<p dir="auto">Prints <code>1 2 3 4</code>.  (5 is false under the predicate)</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1};
for (auto&amp;&amp; i : takewhile([] (int i) {return i &lt; 5;}, ivec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; ivec{<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">6</span>, <span class="pl-c1">5</span>, <span class="pl-c1">4</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : takewhile([] (<span class="pl-k">int</span> i) {<span class="pl-k">return</span> i &lt; <span class="pl-c1">5</span>;}, ivec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">dropwhile</h2><a id="user-content-dropwhile" class="anchor" aria-label="Permalink: dropwhile" href="#dropwhile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Yields all elements after and including the first element that is true under
the predicate.</p>
<p dir="auto">Prints <code>5 6 7 1 2</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6, 7, 1, 2};
for (auto&amp;&amp; i : dropwhile([] (int i) {return i &lt; 5;}, ivec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; ivec{<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : dropwhile([] (<span class="pl-k">int</span> i) {<span class="pl-k">return</span> i &lt; <span class="pl-c1">5</span>;}, ivec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">cycle</h2><a id="user-content-cycle" class="anchor" aria-label="Permalink: cycle" href="#cycle"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Repeatedly produces all values of an iterable.  The loop will be infinite, so a
<code>break</code> or other control flow structure is necessary to exit.</p>
<p dir="auto">Prints <code>1 2 3</code> repeatedly until <code>some_condition</code> is true</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec{1, 2, 3};
for (auto&amp;&amp; i : cycle(vec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
    if (some_condition) {
        break;
    }
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : cycle(vec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    <span class="pl-k">if</span> (some_condition) {
        <span class="pl-k">break</span>;
    }
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">repeat</h2><a id="user-content-repeat" class="anchor" aria-label="Permalink: repeat" href="#repeat"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Repeatedly produces a single argument forever, or a given number of times.
<code>repeat</code> will bind a reference when passed an lvalue and move when given
an rvalue.  It will then yield a reference to the same item until completion.</p>
<p dir="auto">The below prints <code>1</code> five times.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; e : repeat(1, 5)) {
    cout &lt;&lt; e &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; e : repeat(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>)) {
    cout &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">The below prints <code>2</code> forever</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; e : repeat(2)) {
    cout &lt;&lt; e &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; e : repeat(<span class="pl-c1">2</span>)) {
    cout &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">count</h2><a id="user-content-count" class="anchor" aria-label="Permalink: count" href="#count"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Effectively a <code>range</code> without a stopping point.<br>
<code>count()</code> with no arguments will start counting from 0 with a positive
step of 1.<br>
<code>count(i)</code> will start counting from <code>i</code> with a positive step of 1.<br>
<code>count(i, st)</code> will start counting from <code>i</code> with a step of <code>st</code>.</p>
<p dir="auto"><em>Technical limitations</em>: Unlike Python which can use its long integer
types when needed, <code>count()</code> would eventually exceed the
maximum possible value for its type (or minimum with a negative step).
<code>count</code> is actually implemented as a <code>range</code> with the stopping point
being the <code>std::numeric_limits&lt;T&gt;::max()</code> for the integral type (<code>long</code>
by default)</p>
<p dir="auto">The below will print <code>0 1 2</code> ... etc</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; i : count()) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : count()) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">groupby</h2><a id="user-content-groupby" class="anchor" aria-label="Permalink: groupby" href="#groupby"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: If the Input's iterator's <code>operator*()</code> returns
a reference, the reference must remain valid after the iterator is incremented.
Roughly equivalent to requiring the Input have a ForwardIterator.</p>
<p dir="auto">Separate an iterable into groups sharing a common key.  The following example
creates a new group whenever a string of a different length is encountered.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;string&gt; vec = {
    &quot;hi&quot;, &quot;ab&quot;, &quot;ho&quot;,
    &quot;abc&quot;, &quot;def&quot;,
    &quot;abcde&quot;, &quot;efghi&quot;
};

for (auto&amp;&amp; gb : groupby(vec, [] (const string &amp;s) {return s.length(); })) {
    cout &lt;&lt; &quot;key: &quot; &lt;&lt; gb.first &lt;&lt; '\n';
    cout &lt;&lt; &quot;content: &quot;;
    for (auto&amp;&amp; s : gb.second) {
        cout &lt;&lt; s &lt;&lt; &quot;  &quot;;
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;string&gt; vec = {
    <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ho<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>abcde<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>efghi<span class="pl-pds">"</span></span>
};

<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; gb : groupby(vec, [] (<span class="pl-k">const</span> string &amp;s) {<span class="pl-k">return</span> s.<span class="pl-c1">length</span>(); })) {
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>key: <span class="pl-pds">"</span></span> &lt;&lt; gb.<span class="pl-smi">first</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>content: <span class="pl-pds">"</span></span>;
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; s : gb.<span class="pl-smi">second</span>) {
        cout &lt;&lt; s &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>  <span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto"><em>Note</em>: Just like Python's <code>itertools.groupby</code>, this doesn't do any sorting.
It just iterates through, making a new group each time there is a key change.
Thus, if the group is unsorted, the same key may appear multiple times.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">starmap</h2><a id="user-content-starmap" class="anchor" aria-label="Permalink: starmap" href="#starmap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Takes a sequence of tuple-like objects (anything that works with <code>std::get</code>)
and unpacks each object into individual arguments for each function call.
The below example takes a <code>vector</code> of <code>pairs</code> of ints, and passes them
to a function expecting two ints, with the elements of the <code>pair</code> being
the first and second arguments to the function.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;pair&lt;int, int&gt;&gt; v = {{2, 3}, {5, 2}, {3, 4}}; // {base, exponent}
for (auto&amp;&amp; i : starmap([](int b, int e){return pow(b, e);}, v)) {
    // ...
}"><pre>vector&lt;pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt;&gt; v = {{<span class="pl-c1">2</span>, <span class="pl-c1">3</span>}, {<span class="pl-c1">5</span>, <span class="pl-c1">2</span>}, {<span class="pl-c1">3</span>, <span class="pl-c1">4</span>}}; <span class="pl-c"><span class="pl-c">//</span> {base, exponent}</span>
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : starmap([](<span class="pl-k">int</span> b, <span class="pl-k">int</span> e){<span class="pl-k">return</span> <span class="pl-c1">pow</span>(b, e);}, v)) {
    <span class="pl-c"><span class="pl-c">//</span> ...</span>
}</pre></div>
<p dir="auto"><code>starmap</code> can also work over a tuple-like object of tuple-like objects even
when the contained objects are different as long as the functor works with
multiple types of calls.  For example, a <code>Callable</code> struct with overloads
for its <code>operator()</code> will work as long as all overloads have the same
return type</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Callable {
    int operator()(int i) const;
    int operator()(int i, char c) const;
    int operator()(double d, int i, char c) const;
};"><pre><span class="pl-k">struct</span> <span class="pl-en">Callable</span> {
    <span class="pl-k">int</span> <span class="pl-en">operator</span>()(<span class="pl-k">int</span> i) <span class="pl-k">const</span>;
    <span class="pl-k">int</span> <span class="pl-en">operator</span>()(<span class="pl-k">int</span> i, <span class="pl-k">char</span> c) <span class="pl-k">const</span>;
    <span class="pl-k">int</span> <span class="pl-en">operator</span>()(<span class="pl-k">double</span> d, <span class="pl-k">int</span> i, <span class="pl-k">char</span> c) <span class="pl-k">const</span>;
};</pre></div>
<p dir="auto">This will work with a tuple of mixed types</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto t = make_tuple(
        make_tuple(5), // first form
        make_pair(3, 'c'), // second
        make_tuple(1.0, 1, '1')); // third
for (auto&amp;&amp; i : starmap(Callable{}, t)) {
    // ...
}"><pre><span class="pl-k">auto</span> t = make_tuple(
        <span class="pl-en">make_tuple</span>(<span class="pl-c1">5</span>), <span class="pl-c"><span class="pl-c">//</span> first form</span>
        make_pair(<span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>), <span class="pl-c"><span class="pl-c">//</span> second</span>
        make_tuple(<span class="pl-c1">1.0</span>, <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>)); <span class="pl-c"><span class="pl-c">//</span> third</span>
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : starmap(Callable{}, t)) {
    <span class="pl-c"><span class="pl-c">//</span> ...</span>
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">accumulate</h2><a id="user-content-accumulate" class="anchor" aria-label="Permalink: accumulate" href="#accumulate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Type return from functor (with reference removed)
must be assignable.</p>
<p dir="auto">Differs from <code>std::accumulate</code> (which in my humble opinion should be named
<code>std::reduce</code> or <code>std::foldl</code>).  It is similar to a functional reduce where one
can see all of the intermediate results.  By default, it keeps a running sum.
Prints: <code>1 3 6 10 15</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; i : accumulate(range(1, 6))) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : accumulate(range(<span class="pl-c1">1</span>, <span class="pl-c1">6</span>))) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">A second, optional argument may provide an alternative binary function
to compute results.  The following example multiplies the numbers, rather
than adding them.
Prints: <code>1 2 6 24 120</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; i : accumulate(range(1, 6), std::multiplies&lt;int&gt;{})) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : accumulate(range(<span class="pl-c1">1</span>, <span class="pl-c1">6</span>), std::multiplies&lt;<span class="pl-k">int</span>&gt;{})) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">Note: The intermediate result type must support default construction
and assignment.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">zip</h2><a id="user-content-zip" class="anchor" aria-label="Permalink: zip" href="#zip"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Takes an arbitrary number of ranges of different types and efficiently iterates
over them in parallel (so an iterator to each container is incremented
simultaneously).  When you dereference an iterator to "zipped" range you get a
tuple of the elements the iterators were holding.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="array&lt;int,4&gt; iseq{{1,2,3,4}};
vector&lt;float&gt; fseq{1.2,1.4,12.3,4.5,9.9};
vector&lt;string&gt; sseq{&quot;i&quot;,&quot;like&quot;,&quot;apples&quot;,&quot;a lot&quot;,&quot;dude&quot;};
array&lt;double,5&gt; dseq{{1.2,1.2,1.2,1.2,1.2}};

for (auto&amp;&amp; [i, f, s, d] : zip(iseq, fseq, sseq, dseq)) {
    cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; f &lt;&lt; ' ' &lt;&lt; s &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\n';
    f = 2.2f; // modifies the underlying 'fseq' sequence
}"><pre>array&lt;<span class="pl-k">int</span>,<span class="pl-c1">4</span>&gt; iseq{{<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>}};
vector&lt;<span class="pl-k">float</span>&gt; fseq{<span class="pl-c1">1.2</span>,<span class="pl-c1">1.4</span>,<span class="pl-c1">12.3</span>,<span class="pl-c1">4.5</span>,<span class="pl-c1">9.9</span>};
vector&lt;string&gt; sseq{<span class="pl-s"><span class="pl-pds">"</span>i<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>like<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>apples<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>a lot<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>dude<span class="pl-pds">"</span></span>};
array&lt;<span class="pl-k">double</span>,<span class="pl-c1">5</span>&gt; dseq{{<span class="pl-c1">1.2</span>,<span class="pl-c1">1.2</span>,<span class="pl-c1">1.2</span>,<span class="pl-c1">1.2</span>,<span class="pl-c1">1.2</span>}};

<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; [i, f, s, d] : zip(iseq, fseq, sseq, dseq)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &lt;&lt; f &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &lt;&lt; s &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &lt;&lt; d &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    f = <span class="pl-c1">2</span>.<span class="pl-c1">2f</span>; <span class="pl-c"><span class="pl-c">//</span> modifies the underlying 'fseq' sequence</span>
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">zip_longest</h2><a id="user-content-zip_longest" class="anchor" aria-label="Permalink: zip_longest" href="#zip_longest"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Terminates on the longest sequence instead of the shortest.
Repeatedly yields a tuple of <code>boost::optional&lt;T&gt;</code>s where <code>T</code> is the type
yielded by the sequences' respective iterators.  Because of its boost
dependency, <code>zip_longest</code> is not in <code>itertools.hpp</code> and must be included
separately.
The following loop prints either "Just &lt;item&gt;" or "Nothing" for each
element in each tuple yielded.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v1 = {0, 1, 2, 3};
vector&lt;int&gt; v2 = {10, 11};
for (auto&amp;&amp; [x, y] : zip_longest(v1, v2)) {
    cout &lt;&lt; '{';
    if (x) {
        cout &lt;&lt; &quot;Just &quot; &lt;&lt; *x;
    } else {
        cout &lt;&lt; &quot;Nothing&quot;;
    }
    cout &lt;&lt; &quot;, &quot;;
    if (y) {
        cout &lt;&lt; &quot;Just &quot; &lt;&lt; *y;
    } else {
        cout &lt;&lt; &quot;Nothing&quot;;
    }
    cout &lt;&lt; &quot;}\n&quot;;
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v1 = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>};
vector&lt;<span class="pl-k">int</span>&gt; v2 = {<span class="pl-c1">10</span>, <span class="pl-c1">11</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; [x, y] : zip_longest(v1, v2)) {
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span>{<span class="pl-pds">'</span></span>;
    <span class="pl-k">if</span> (x) {
        cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Just <span class="pl-pds">"</span></span> &lt;&lt; *x;
    } <span class="pl-k">else</span> {
        cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Nothing<span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>;
    <span class="pl-k">if</span> (y) {
        cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Just <span class="pl-pds">"</span></span> &lt;&lt; *y;
    } <span class="pl-k">else</span> {
        cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Nothing<span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>}<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
}</pre></div>
<p dir="auto">The output is:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="{Just 0, Just 10}
{Just 1, Just 11}
{Just 2, Nothing}
{Just 3, Nothing}"><pre class="notranslate"><code>{Just 0, Just 10}
{Just 1, Just 11}
{Just 2, Nothing}
{Just 3, Nothing}
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">imap</h2><a id="user-content-imap" class="anchor" aria-label="Permalink: imap" href="#imap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Takes a function and one or more iterables.  The number of iterables must
match the number of arguments to the function.  Applies the function to
each element (or elements) in the iterable(s).  Terminates on the shortest
sequence.</p>
<p dir="auto">Prints the squares of the numbers in vec: <code>1 4 9 16 25</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec{1, 2, 3, 4, 5};
for (auto&amp;&amp; i : imap([] (int x) {return x * x;}, vec)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec{<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : imap([] (<span class="pl-k">int</span> x) {<span class="pl-k">return</span> x * x;}, vec)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">With more than one sequence, the below adds corresponding elements from
each vector together, printing <code>11 23 35 47 59 71</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec1{1, 3, 5, 7, 9, 11};
vector&lt;int&gt; vec2{10, 20, 30, 40, 50, 60};
for (auto&amp;&amp; i : imap([] (int x, int y) { return x + y; }, vec1, vec2)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec1{<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>, <span class="pl-c1">7</span>, <span class="pl-c1">9</span>, <span class="pl-c1">11</span>};
vector&lt;<span class="pl-k">int</span>&gt; vec2{<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">40</span>, <span class="pl-c1">50</span>, <span class="pl-c1">60</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : imap([] (<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) { <span class="pl-k">return</span> x + y; }, vec1, vec2)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto"><em>Note</em>: The name <code>imap</code> is chosen to prevent confusion/collision with
<code>std::map</code>, and because it is more related to <code>itertools.imap</code> than
the python builtin <code>map</code>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">compress</h2><a id="user-content-compress" class="anchor" aria-label="Permalink: compress" href="#compress"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Yields only the values corresponding to true in the selectors iterable.
Terminates on the shortest sequence.</p>
<p dir="auto">Prints <code>2 6</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6};
vector&lt;bool&gt; bvec{false, true, false, false, false, true};
for (auto&amp;&amp; i : compress(ivec, bvec) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; ivec{<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>};
vector&lt;<span class="pl-k">bool</span>&gt; bvec{<span class="pl-c1">false</span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">true</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : compress(ivec, bvec) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">sorted</h2><a id="user-content-sorted" class="anchor" aria-label="Permalink: sorted" href="#sorted"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Allows iteration over a sequence in sorted order. <code>sorted</code> does
<strong>not</strong> produce a new sequence, copy elements, or modify the original
sequence.  It only provides a way to iterate over existing elements.
<code>sorted</code> also takes an optional second
<a href="http://en.cppreference.com/w/cpp/concept/Compare" rel="nofollow">comparator</a>
argument.  If not provided, defaults to <code>std::less</code>. <br>
Iterables passed to sorted are required to have an iterator with
an <code>operator*() const</code> member.</p>
<p dir="auto">The below outputs <code>0 1 2 3 4</code>.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="unordered_set&lt;int&gt; nums{4, 0, 2, 1, 3};
for (auto&amp;&amp; i : sorted(nums)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>unordered_set&lt;<span class="pl-k">int</span>&gt; nums{<span class="pl-c1">4</span>, <span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : sorted(nums)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">chain</h2><a id="user-content-chain" class="anchor" aria-label="Permalink: chain" href="#chain"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: The underlying iterators of all containers'
<code>operator*</code> must have the <em>exact</em> same type</p>
<p dir="auto">This can chain any set of ranges together as long as their iterators
dereference to the same type.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; empty{};
vector&lt;int&gt; vec1{1,2,3,4,5,6};
array&lt;int,4&gt; arr1{{7,8,9,10}};

for (auto&amp;&amp; i : chain(empty,vec1,arr1)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; empty{};
vector&lt;<span class="pl-k">int</span>&gt; vec1{<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>};
array&lt;<span class="pl-k">int</span>,<span class="pl-c1">4</span>&gt; arr1{{<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">10</span>}};

<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : chain(empty,vec1,arr1)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">chain.from_iterable</h2><a id="user-content-chainfrom_iterable" class="anchor" aria-label="Permalink: chain.from_iterable" href="#chainfrom_iterable"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Similar to chain, but rather than taking a variadic number of iterables,
it takes an iterable of iterables and chains the contained iterables together.
A simple example is shown below using a vector of vectors to represent
a 2d ragged array, and prints it in row-major order.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;vector&lt;int&gt;&gt; matrix = {
    {1, 2, 3},
    {4, 5},
    {6, 8, 9, 10, 11, 12}
};

for (auto&amp;&amp; i : chain.from_iterable(matrix)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;vector&lt;<span class="pl-k">int</span>&gt;&gt; matrix = {
    {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>},
    {<span class="pl-c1">4</span>, <span class="pl-c1">5</span>},
    {<span class="pl-c1">6</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>}
};

<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : chain.from_iterable(matrix)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">reversed</h2><a id="user-content-reversed" class="anchor" aria-label="Permalink: reversed" href="#reversed"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must be compatible with <code>std::rbegin()</code> and
<code>std::rend()</code></p>
<p dir="auto">Iterates over elements of a sequence in reverse order.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; i : reversed(a)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : reversed(a)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">slice</h2><a id="user-content-slice" class="anchor" aria-label="Permalink: slice" href="#slice"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Returns selected elements from a range, parameters are start, stop and step.
the range returned is [start,stop) where you only take every step element</p>
<p dir="auto">This outputs <code>0 3 6 9 12</code></p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; a{0,1,2,3,4,5,6,7,8,9,10,11,12,13};
for (auto&amp;&amp; i : slice(a,0,15,3)) {
    cout &lt;&lt; i &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; a{<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">10</span>,<span class="pl-c1">11</span>,<span class="pl-c1">12</span>,<span class="pl-c1">13</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : slice(a,<span class="pl-c1">0</span>,<span class="pl-c1">15</span>,<span class="pl-c1">3</span>)) {
    cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">sliding_window</h2><a id="user-content-sliding_window" class="anchor" aria-label="Permalink: sliding_window" href="#sliding_window"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Takes a section from a range and increments the whole section.  If the
window size is larger than the length of the input, the <code>sliding_window</code> will
yield nothing (begin == end).</p>
<p dir="auto">Example:
<code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p>
<p dir="auto">take a section of size 4, output is:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
5 6 7 8
6 7 8 9"><pre class="notranslate"><code>1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
5 6 7 8
6 7 8 9
</code></pre></div>
<p dir="auto">Example Usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v = {1,2,3,4,5,6,7,8,9};
for (auto&amp;&amp; sec : sliding_window(v,4)) {
    for (auto&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; ' ';
        i.get() = 90;
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v = {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; sec : sliding_window(v,<span class="pl-c1">4</span>)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
        i.<span class="pl-c1">get</span>() = <span class="pl-c1">90</span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">chunked</h2><a id="user-content-chunked" class="anchor" aria-label="Permalink: chunked" href="#chunked"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">chunked will yield subsequent chunks of an iterable in blocks of a specified
size. The final chunk may be shorter than the rest if the chunk size given
does not evenly divide the length of the iterable.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v {1,2,3,4,5,6,7,8,9};
for (auto&amp;&amp; sec : chunked(v,4)) {
    for (auto&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; sec : chunked(v,<span class="pl-c1">4</span>)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">The above prints:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="1 2 3 4
5 6 7 8
9"><pre class="notranslate"><code>1 2 3 4
5 6 7 8
9
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">batched</h2><a id="user-content-batched" class="anchor" aria-label="Permalink: batched" href="#batched"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">batched will yield a given number N of batches containing subsequent elements from an iterable,
assuming the iterable contains at least N elements.
The size of each batch is immaterial, but the implementation guarantees that no two batches will
differ in size by more than 1.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v {1,2,3,4,5,6,7,8,9};
for (auto&amp;&amp; sec : batched(v,4)) {
    for (auto&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; sec : batched(v,<span class="pl-c1">4</span>)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : sec) {
        cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">The above prints:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="1 2 3
4 5
6 7
8 9"><pre class="notranslate"><code>1 2 3
4 5
6 7
8 9
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">product</h2><a id="user-content-product" class="anchor" aria-label="Permalink: product" href="#product"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Generates the cartesian product of the given ranges put together.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v1{1,2,3};
vector&lt;int&gt; v2{7,8};
vector&lt;string&gt; v3{&quot;the&quot;,&quot;cat&quot;};
vector&lt;string&gt; v4{&quot;hi&quot;,&quot;what's&quot;,&quot;up&quot;,&quot;dude&quot;};
for (auto&amp;&amp; [a, b, c, d] : product(v1,v2,v3,v4)) {
    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v1{<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>};
vector&lt;<span class="pl-k">int</span>&gt; v2{<span class="pl-c1">7</span>,<span class="pl-c1">8</span>};
vector&lt;string&gt; v3{<span class="pl-s"><span class="pl-pds">"</span>the<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>};
vector&lt;string&gt; v4{<span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>what's<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>up<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>dude<span class="pl-pds">"</span></span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; [a, b, c, d] : product(v1,v2,v3,v4)) {
    cout &lt;&lt; a &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; b &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; c &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; d &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<p dir="auto">Product also accepts a "repeat" as a template argument. Currently this is the only way to do repeats. <strong>If you are reading this and need <code>product(seq, 3)</code> instead of <code>product&lt;3&gt;(seq)</code> please open an issue</strong>.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="std::string s = &quot;abc&quot;;
// equivalent of product(s, s, s);
for (auto&amp;&amp; t : product&lt;3&gt;(s)) {
   // ...
}"><pre>std::string s = <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>;
<span class="pl-c"><span class="pl-c">//</span> equivalent of product(s, s, s);</span>
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; t : product&lt;<span class="pl-c1">3</span>&gt;(s)) {
   <span class="pl-c"><span class="pl-c">//</span> ...</span>
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">combinations</h2><a id="user-content-combinations" class="anchor" aria-label="Permalink: combinations" href="#combinations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Generates n length unique sequences of the input range.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v = {1,2,3,4,5};
for (auto&amp;&amp; i : combinations(v,3)) {
    for (auto&amp;&amp; j : i ) cout &lt;&lt; j &lt;&lt; &quot; &quot;;
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v = {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : combinations(v,<span class="pl-c1">3</span>)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; j : i ) cout &lt;&lt; j &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">combinations_with_replacement</h2><a id="user-content-combinations_with_replacement" class="anchor" aria-label="Permalink: combinations_with_replacement" href="#combinations_with_replacement"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Like combinations, but with replacement of each element.  The
below is printed by the loop that follows:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="{A, A}
{A, B}
{A, C}
{B, B}
{B, C}
{C, C}"><pre class="notranslate"><code>{A, A}
{A, B}
{A, C}
{B, B}
{B, C}
{C, C}
</code></pre></div>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for (auto&amp;&amp; v : combinations_with_replacement(s, 2)) {
    cout &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; &quot;, &quot; &lt;&lt; v[1] &lt;&lt; &quot;}\n&quot;;
}"><pre><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; v : combinations_with_replacement(s, <span class="pl-c1">2</span>)) {
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span>{<span class="pl-pds">'</span></span> &lt;&lt; v[<span class="pl-c1">0</span>] &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; v[<span class="pl-c1">1</span>] &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>}<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">permutations</h2><a id="user-content-permutations" class="anchor" aria-label="Permalink: permutations" href="#permutations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator.  Iterator must
have an <code>operator*() const</code>.</p>
<p dir="auto">Generates all the permutations of a range using <code>std::next_permutation</code>.</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; v = {1,2,3,4,5};
for (auto&amp;&amp; vec : permutations(v)) {
    for (auto&amp;&amp; i : vec) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; v = {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; vec : permutations(v)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : vec) {
        cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">powerset</h2><a id="user-content-powerset" class="anchor" aria-label="Permalink: powerset" href="#powerset"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p dir="auto">Generates every possible subset of a set, runs in O(2^n).</p>
<p dir="auto">Example usage:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vector&lt;int&gt; vec {1,2,3,4,5,6,7,8,9};
for (auto&amp;&amp; v : powerset(vec)) {
    for (auto&amp;&amp; i : v) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; '\n';
}"><pre>vector&lt;<span class="pl-k">int</span>&gt; vec {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>};
<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; v : powerset(vec)) {
    <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp;&amp; i : v) {
        cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
</article></div>