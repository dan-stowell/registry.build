<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">libccd <a href="https://travis-ci.org/danfis/libccd" rel="nofollow"><img src="https://camo.githubusercontent.com/7c66482be08d9a69387693a13af9312c5100d76db52b91b098d1e8f1853d7187/68747470733a2f2f7472617669732d63692e6f72672f64616e6669732f6c69626363642e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/danfis/libccd.svg?branch=master" style="max-width: 100%; height: auto;"></a></h1><a id="user-content-libccd-" class="anchor" aria-label="Permalink: libccd " href="#libccd-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em><strong>libccd</strong></em> is library for a collision detection between two convex shapes.
libccd implements variation on Gilbert–Johnson–Keerthi algorithm plus Expand
Polytope Algorithm (EPA) and also implements algorithm Minkowski Portal
Refinement (MPR, a.k.a. XenoCollide) as described in Game Programming Gems 7.</p>
<p dir="auto">libccd is the only available open source library of my knowledge that include
MPR algorithm working in 3-D space.  However, there is a library called
<a href="http://code.google.com/p/mpr2d/" rel="nofollow">mpr2d</a>, implemented in D programming
language, that works in 2-D space.</p>
<p dir="auto">libccd is currently part of:</p>
<ol dir="auto">
<li><a href="http://www.ode.org/" rel="nofollow">ODE</a> library (see ODE's <em>./configure --help</em> how to enable it),</li>
<li><a href="http://www.ros.org/wiki/fcl" rel="nofollow">FCL</a> library from <a href="http://www.willowgarage.com/" rel="nofollow">Willow Garage</a>,</li>
<li><a href="http://bulletphysics.org/" rel="nofollow">Bullet3</a> library (<a href="https://github.com/bulletphysics/bullet3">https://github.com/bulletphysics/bullet3</a>).</li>
</ol>
<p dir="auto">For implementation details on GJK algorithm, see
<a href="http://www.win.tue.nl/~gino/solid/jgt98convex.pdf" rel="nofollow">http://www.win.tue.nl/~gino/solid/jgt98convex.pdf</a>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Dependencies</h2><a id="user-content-dependencies" class="anchor" aria-label="Permalink: Dependencies" href="#dependencies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This library is currently based only on standard libraries.
The only exception are testsuites that are built on top of CU
(<a href="https://github.com/danfis/cu">https://github.com/danfis/cu</a>) library licensed under LGPL, however only
testing depends on it and libccd library itself can be distributed without it.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">License</h2><a id="user-content-license" class="anchor" aria-label="Permalink: License" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">libccd is licensed under OSI-approved 3-clause BSD License, text of license
is distributed along with source code in BSD-LICENSE file.
Each file should include license notice, the rest should be considered as
licensed under 3-clause BSD License.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Compile And Install</h2><a id="user-content-compile-and-install" class="anchor" aria-label="Permalink: Compile And Install" href="#compile-and-install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">libccd contains several mechanisms for compiling and installing. Using a simple Makefile, using autotools, and using CMake.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">1. Using Makefile</h3><a id="user-content-1-using-makefile" class="anchor" aria-label="Permalink: 1. Using Makefile" href="#1-using-makefile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Directory src/ contains Makefile that should contain everything needed for compilation and installation:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ cd src/
  $ make
  $ make install"><pre>  $ <span class="pl-c1">cd</span> src/
  $ make
  $ make install</pre></div>
<p dir="auto">Library libccd is by default compiled in double precision of floating point numbers - you can change this by options <em>USE_SINGLE/USE_DOUBLE</em>, i.e.:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ make USE_SINGLE=yes"><pre>  $ make USE_SINGLE=yes</pre></div>
<p dir="auto">will compile library in single precision.</p>
<p dir="auto">Installation directory can be changed by options PREFIX, INCLUDEDIR and LIBDIR.
For more info type 'make help'.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">2. Using Autotools</h3><a id="user-content-2-using-autotools" class="anchor" aria-label="Permalink: 2. Using Autotools" href="#2-using-autotools"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">libccd also contains support for autotools:
Generate configure script etc.:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ ./bootstrap"><pre>  $ ./bootstrap</pre></div>
<p dir="auto">Create new build/ directory:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build</pre></div>
<p dir="auto">Run configure script:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ ../configure"><pre>  $ ../configure</pre></div>
<p dir="auto">Run make and make install:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ make &amp;&amp; make install"><pre>  $ make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<p dir="auto">configure script can change the way libccd is compiled and installed, most significant option is <em>--enable-double-precision</em> which enables double precision (single is default in this case).</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">3. Using CMake</h3><a id="user-content-3-using-cmake" class="anchor" aria-label="Permalink: 3. Using CMake" href="#3-using-cmake"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To build using <code>make</code>:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G &quot;Unix Makefiles&quot; ..
  $ make &amp;&amp; make install"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G <span class="pl-s"><span class="pl-pds">"</span>Unix Makefiles<span class="pl-pds">"</span></span> ..
  $ make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<p dir="auto">To build using <code>ninja</code>:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G Ninja ..
  $ ninja &amp;&amp; ninja install"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G Ninja ..
  $ ninja <span class="pl-k">&amp;&amp;</span> ninja install</pre></div>
<p dir="auto">Other build tools may be using by specifying a different generator. For example:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ cmake -G Xcode .."><pre>  $ cmake -G Xcode ..</pre></div>
<div class="highlight highlight-source-batchfile notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  &gt; cmake -G &quot;Visual Studio 14 2015&quot; .."><pre>  <span class="pl-k">&gt;</span> cmake -G <span class="pl-s"><span class="pl-pds">"</span>Visual Studio 14 2015<span class="pl-pds">"</span></span> ..</pre></div>
<p dir="auto">To compile using double precision, set the <code>ENABLE_DOUBLE_PRECISION</code> option:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G &quot;Unix Makefiles&quot; -DENABLE_DOUBLE_PRECISION=ON ..
  $ make &amp;&amp; make install"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G <span class="pl-s"><span class="pl-pds">"</span>Unix Makefiles<span class="pl-pds">"</span></span> -DENABLE_DOUBLE_PRECISION=ON ..
  $ make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<p dir="auto">To build libccd as a shared library, set the <code>BUILD_SHARED_LIBS</code> option:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G &quot;Unix Makefiles&quot; -DBUILD_SHARED_LIBS=ON ..
  $ make &amp;&amp; make install"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G <span class="pl-s"><span class="pl-pds">"</span>Unix Makefiles<span class="pl-pds">"</span></span> -DBUILD_SHARED_LIBS=ON ..
  $ make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<p dir="auto">To build the test suite, set the <code>BUILD_TESTING</code> option:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G &quot;Unix Makefiles&quot; -DBUILD_TESTING=ON ..
  $ make &amp;&amp; make test"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G <span class="pl-s"><span class="pl-pds">"</span>Unix Makefiles<span class="pl-pds">"</span></span> -DBUILD_TESTING=ON ..
  $ make <span class="pl-k">&amp;&amp;</span> make <span class="pl-c1">test</span></pre></div>
<p dir="auto">The installation directory may be changed using the <code>CMAKE_INSTALL_PREFIX</code> variable:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  $ mkdir build &amp;&amp; cd build
  $ cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/path/to/install ..
  $ make &amp;&amp; make install"><pre>  $ mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
  $ cmake -G <span class="pl-s"><span class="pl-pds">"</span>Unix Makefiles<span class="pl-pds">"</span></span> -DCMAKE_INSTALL_PREFIX=/path/to/install ..
  $ make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">GJK - Intersection Test</h2><a id="user-content-gjk---intersection-test" class="anchor" aria-label="Permalink: GJK - Intersection Test" href="#gjk---intersection-test"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This section describes how to use libccd for testing if two convex objects intersects (i.e., 'yes/no' test) using Gilbert-Johnson-Keerthi (GJK) algorithm.</p>
<p dir="auto">Procedure is very simple (and is similar for usages of library):</p>
<ol dir="auto">
<li>Include <em>&lt;ccd/ccd.h&gt;</em> file.</li>
<li>Implement support function for specific shapes. Support function is function that returns furthest point from object (shape) in specified direction.</li>
<li>Set up <em>ccd_t</em> structure.</li>
<li>Run ccdGJKIntersect() function on desired objects.</li>
</ol>
<p dir="auto">Here is skeleton of simple program:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  #include &lt;ccd/ccd.h&gt;
  #include &lt;ccd/quat.h&gt; // for work with quaternions

  /** Support function for box */
  void support(const void *obj, const ccd_vec3_t *dir, ccd_vec3_t *vec)
  {
      // assume that obj_t is user-defined structure that holds info about
      // object (in this case box: x, y, z, pos, quat - dimensions of box,
      // position and rotation)
      obj_t *obj = (obj_t *)_obj;
      ccd_vec3_t dir;
      ccd_quat_t qinv;

      // apply rotation on direction vector
      ccdVec3Copy(&amp;dir, _dir);
      ccdQuatInvert2(&amp;qinv, &amp;obj-&gt;quat);
      ccdQuatRotVec(&amp;dir, &amp;qinv);

      // compute support point in specified direction
      ccdVec3Set(v, ccdSign(ccdVec3X(&amp;dir)) * box-&gt;x * CCD_REAL(0.5),
                    ccdSign(ccdVec3Y(&amp;dir)) * box-&gt;y * CCD_REAL(0.5),
                    ccdSign(ccdVec3Z(&amp;dir)) * box-&gt;z * CCD_REAL(0.5));

      // transform support point according to position and rotation of object
      ccdQuatRotVec(v, &amp;obj-&gt;quat);
      ccdVec3Add(v, &amp;obj-&gt;pos);
  }

  int main(int argc, char *argv[])
  {
      ...

      ccd_t ccd;
      CCD_INIT(&amp;ccd); // initialize ccd_t struct

      // set up ccd_t struct
      ccd.support1       = support; // support function for first object
      ccd.support2       = support; // support function for second object
      ccd.max_iterations = 100;     // maximal number of iterations

      int intersect = ccdGJKIntersect(obj1, obj2, &amp;ccd);
      // now intersect holds true if obj1 and obj2 intersect, false otherwise
  }"><pre>  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/ccd.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/quat.h<span class="pl-pds">&gt;</span></span> <span class="pl-c"><span class="pl-c">//</span> for work with quaternions</span>

  <span class="pl-c"><span class="pl-c">/*</span>* Support function for box <span class="pl-c">*/</span></span>
  <span class="pl-k">void</span> <span class="pl-en">support</span>(<span class="pl-k">const</span> <span class="pl-k">void</span> *obj, <span class="pl-k">const</span> <span class="pl-c1">ccd_vec3_t</span> *dir, <span class="pl-c1">ccd_vec3_t</span> *vec)
  {
      <span class="pl-c"><span class="pl-c">//</span> assume that obj_t is user-defined structure that holds info about</span>
      <span class="pl-c"><span class="pl-c">//</span> object (in this case box: x, y, z, pos, quat - dimensions of box,</span>
      <span class="pl-c"><span class="pl-c">//</span> position and rotation)</span>
      <span class="pl-c1">obj_t</span> *obj = (<span class="pl-c1">obj_t</span> *)_obj;
      <span class="pl-c1">ccd_vec3_t</span> dir;
      <span class="pl-c1">ccd_quat_t</span> qinv;

      <span class="pl-c"><span class="pl-c">//</span> apply rotation on direction vector</span>
      <span class="pl-c1">ccdVec3Copy</span>(&amp;dir, _dir);
      <span class="pl-c1">ccdQuatInvert2</span>(&amp;qinv, &amp;obj-&gt;<span class="pl-smi">quat</span>);
      <span class="pl-c1">ccdQuatRotVec</span>(&amp;dir, &amp;qinv);

      <span class="pl-c"><span class="pl-c">//</span> compute support point in specified direction</span>
      <span class="pl-c1">ccdVec3Set</span>(v, <span class="pl-c1">ccdSign</span>(<span class="pl-c1">ccdVec3X</span>(&amp;dir)) * box-&gt;<span class="pl-smi">x</span> * <span class="pl-c1">CCD_REAL</span>(<span class="pl-c1">0.5</span>),
                    <span class="pl-c1">ccdSign</span>(<span class="pl-c1">ccdVec3Y</span>(&amp;dir)) * box-&gt;<span class="pl-smi">y</span> * <span class="pl-c1">CCD_REAL</span>(<span class="pl-c1">0.5</span>),
                    <span class="pl-c1">ccdSign</span>(<span class="pl-c1">ccdVec3Z</span>(&amp;dir)) * box-&gt;<span class="pl-smi">z</span> * <span class="pl-c1">CCD_REAL</span>(<span class="pl-c1">0.5</span>));

      <span class="pl-c"><span class="pl-c">//</span> transform support point according to position and rotation of object</span>
      <span class="pl-c1">ccdQuatRotVec</span>(v, &amp;obj-&gt;<span class="pl-smi">quat</span>);
      <span class="pl-c1">ccdVec3Add</span>(v, &amp;obj-&gt;<span class="pl-smi">pos</span>);
  }

  <span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> *argv[])
  {
      ...

      <span class="pl-c1">ccd_t</span> ccd;
      <span class="pl-c1">CCD_INIT</span>(&amp;ccd); <span class="pl-c"><span class="pl-c">//</span> initialize ccd_t struct</span>

      <span class="pl-c"><span class="pl-c">//</span> set up ccd_t struct</span>
      ccd.<span class="pl-smi">support1</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for first object</span>
      ccd.<span class="pl-smi">support2</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for second object</span>
      ccd.<span class="pl-smi">max_iterations</span> = <span class="pl-c1">100</span>;     <span class="pl-c"><span class="pl-c">//</span> maximal number of iterations</span>

      <span class="pl-k">int</span> intersect = <span class="pl-c1">ccdGJKIntersect</span>(obj1, obj2, &amp;ccd);
      <span class="pl-c"><span class="pl-c">//</span> now intersect holds true if obj1 and obj2 intersect, false otherwise</span>
  }</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">GJK + EPA - Penetration Of Two Objects</h2><a id="user-content-gjk--epa---penetration-of-two-objects" class="anchor" aria-label="Permalink: GJK + EPA - Penetration Of Two Objects" href="#gjk--epa---penetration-of-two-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you want to obtain also penetration info about two intersection objects ccdGJKPenetration() function can be used.</p>
<p dir="auto">Procedure is almost same as for previous case:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  #include &lt;ccd/ccd.h&gt;
  #include &lt;ccd/quat.h&gt; // for work with quaternions

  /** Support function is same as in previous case */

  int main(int argc, char *argv[])
  {
      ...
      ccd_t ccd;
      CCD_INIT(&amp;ccd); // initialize ccd_t struct

      // set up ccd_t struct
      ccd.support1       = support; // support function for first object
      ccd.support2       = support; // support function for second object
      ccd.max_iterations = 100;     // maximal number of iterations
      ccd.epa_tolerance  = 0.0001;  // maximal tolerance fro EPA part

      ccd_real_t depth;
      ccd_vec3_t dir, pos;
      int intersect = ccdGJKPenetration(obj1, obj2, &amp;ccd, &amp;depth, &amp;dir, &amp;pos);
      // now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise
      // in depth, dir and pos is stored penetration depth, direction of
      // separation vector and position in global coordinate system
  }"><pre>  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/ccd.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/quat.h<span class="pl-pds">&gt;</span></span> <span class="pl-c"><span class="pl-c">//</span> for work with quaternions</span>

  <span class="pl-c"><span class="pl-c">/*</span>* Support function is same as in previous case <span class="pl-c">*/</span></span>

  <span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> *argv[])
  {
      ...
      <span class="pl-c1">ccd_t</span> ccd;
      <span class="pl-c1">CCD_INIT</span>(&amp;ccd); <span class="pl-c"><span class="pl-c">//</span> initialize ccd_t struct</span>

      <span class="pl-c"><span class="pl-c">//</span> set up ccd_t struct</span>
      ccd.<span class="pl-smi">support1</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for first object</span>
      ccd.<span class="pl-smi">support2</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for second object</span>
      ccd.<span class="pl-smi">max_iterations</span> = <span class="pl-c1">100</span>;     <span class="pl-c"><span class="pl-c">//</span> maximal number of iterations</span>
      ccd.<span class="pl-smi">epa_tolerance</span>  = <span class="pl-c1">0.0001</span>;  <span class="pl-c"><span class="pl-c">//</span> maximal tolerance fro EPA part</span>

      <span class="pl-c1">ccd_real_t</span> depth;
      <span class="pl-c1">ccd_vec3_t</span> dir, pos;
      <span class="pl-k">int</span> intersect = <span class="pl-c1">ccdGJKPenetration</span>(obj1, obj2, &amp;ccd, &amp;depth, &amp;dir, &amp;pos);
      <span class="pl-c"><span class="pl-c">//</span> now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise</span>
      <span class="pl-c"><span class="pl-c">//</span> in depth, dir and pos is stored penetration depth, direction of</span>
      <span class="pl-c"><span class="pl-c">//</span> separation vector and position in global coordinate system</span>
  }</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">MPR - Intersection Test</h2><a id="user-content-mpr---intersection-test" class="anchor" aria-label="Permalink: MPR - Intersection Test" href="#mpr---intersection-test"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">libccd also provides MPR - Minkowski Portal Refinement algorithm that can be used for testing if two objects intersects.</p>
<p dir="auto">Procedure is similar to the one used for GJK algorithm. Support function is same but also function that returns center (or any point near center) of given object must be implemented:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  #include &lt;ccd/ccd.h&gt;
  #include &lt;ccd/quat.h&gt; // for work with quaternions

  /** Support function is same as in previous case */

  /** Center function - returns center of object */
  void center(const void *_obj, ccd_vec3_t *center)
  {
      obj_t *obj = (obj_t *)_obj;
      ccdVec3Copy(center, &amp;obj-&gt;pos);
  }

  int main(int argc, char *argv[])
  {
      ...
      ccd_t ccd;
      CCD_INIT(&amp;ccd); // initialize ccd_t struct

      // set up ccd_t struct
      ccd.support1       = support; // support function for first object
      ccd.support2       = support; // support function for second object
      ccd.center1        = center;  // center function for first object
      ccd.center2        = center;  // center function for second object
      ccd.mpr_tolerance  = 0.0001;  // maximal tolerance

      int intersect = ccdMPRIntersect(obj1, obj2, &amp;ccd);
      // now intersect holds true if obj1 and obj2 intersect, false otherwise
  }"><pre>  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/ccd.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/quat.h<span class="pl-pds">&gt;</span></span> <span class="pl-c"><span class="pl-c">//</span> for work with quaternions</span>

  <span class="pl-c"><span class="pl-c">/*</span>* Support function is same as in previous case <span class="pl-c">*/</span></span>

  <span class="pl-c"><span class="pl-c">/*</span>* Center function - returns center of object <span class="pl-c">*/</span></span>
  <span class="pl-k">void</span> <span class="pl-en">center</span>(<span class="pl-k">const</span> <span class="pl-k">void</span> *_obj, <span class="pl-c1">ccd_vec3_t</span> *center)
  {
      <span class="pl-c1">obj_t</span> *obj = (<span class="pl-c1">obj_t</span> *)_obj;
      <span class="pl-c1">ccdVec3Copy</span>(center, &amp;obj-&gt;<span class="pl-smi">pos</span>);
  }

  <span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> *argv[])
  {
      ...
      <span class="pl-c1">ccd_t</span> ccd;
      <span class="pl-c1">CCD_INIT</span>(&amp;ccd); <span class="pl-c"><span class="pl-c">//</span> initialize ccd_t struct</span>

      <span class="pl-c"><span class="pl-c">//</span> set up ccd_t struct</span>
      ccd.<span class="pl-smi">support1</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for first object</span>
      ccd.<span class="pl-smi">support2</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for second object</span>
      ccd.<span class="pl-smi">center1</span>        = center;  <span class="pl-c"><span class="pl-c">//</span> center function for first object</span>
      ccd.<span class="pl-smi">center2</span>        = center;  <span class="pl-c"><span class="pl-c">//</span> center function for second object</span>
      ccd.<span class="pl-smi">mpr_tolerance</span>  = <span class="pl-c1">0.0001</span>;  <span class="pl-c"><span class="pl-c">//</span> maximal tolerance</span>

      <span class="pl-k">int</span> intersect = <span class="pl-c1">ccdMPRIntersect</span>(obj1, obj2, &amp;ccd);
      <span class="pl-c"><span class="pl-c">//</span> now intersect holds true if obj1 and obj2 intersect, false otherwise</span>
  }</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">MPR - Penetration Of Two Objects</h2><a id="user-content-mpr---penetration-of-two-objects" class="anchor" aria-label="Permalink: MPR - Penetration Of Two Objects" href="#mpr---penetration-of-two-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Using MPR algorithm for obtaining penetration info about two intersection objects is equally easy as in previous case instead ccdMPRPenetration() function is used:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  #include &lt;ccd/ccd.h&gt;
  #include &lt;ccd/quat.h&gt; // for work with quaternions

  /** Support function is same as in previous case */
  /** Center function is same as in prevous case */

  int main(int argc, char *argv[])
  {
      ...
      ccd_t ccd;
      CCD_INIT(&amp;ccd); // initialize ccd_t struct

      // set up ccd_t struct
      ccd.support1       = support; // support function for first object
      ccd.support2       = support; // support function for second object
      ccd.center1        = center;  // center function for first object
      ccd.center2        = center;  // center function for second object
      ccd.mpr_tolerance  = 0.0001;  // maximal tolerance

      ccd_real_t depth;
      ccd_vec3_t dir, pos;
      int intersect = ccdMPRPenetration(obj1, obj2, &amp;ccd, &amp;depth, &amp;dir, &amp;pos);
      // now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise
      // in depth, dir and pos is stored penetration depth, direction of
      // separation vector and position in global coordinate system
  }"><pre>  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/ccd.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ccd/quat.h<span class="pl-pds">&gt;</span></span> <span class="pl-c"><span class="pl-c">//</span> for work with quaternions</span>

  <span class="pl-c"><span class="pl-c">/*</span>* Support function is same as in previous case <span class="pl-c">*/</span></span>
  <span class="pl-c"><span class="pl-c">/*</span>* Center function is same as in prevous case <span class="pl-c">*/</span></span>

  <span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> *argv[])
  {
      ...
      <span class="pl-c1">ccd_t</span> ccd;
      <span class="pl-c1">CCD_INIT</span>(&amp;ccd); <span class="pl-c"><span class="pl-c">//</span> initialize ccd_t struct</span>

      <span class="pl-c"><span class="pl-c">//</span> set up ccd_t struct</span>
      ccd.<span class="pl-smi">support1</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for first object</span>
      ccd.<span class="pl-smi">support2</span>       = support; <span class="pl-c"><span class="pl-c">//</span> support function for second object</span>
      ccd.<span class="pl-smi">center1</span>        = center;  <span class="pl-c"><span class="pl-c">//</span> center function for first object</span>
      ccd.<span class="pl-smi">center2</span>        = center;  <span class="pl-c"><span class="pl-c">//</span> center function for second object</span>
      ccd.<span class="pl-smi">mpr_tolerance</span>  = <span class="pl-c1">0.0001</span>;  <span class="pl-c"><span class="pl-c">//</span> maximal tolerance</span>

      <span class="pl-c1">ccd_real_t</span> depth;
      <span class="pl-c1">ccd_vec3_t</span> dir, pos;
      <span class="pl-k">int</span> intersect = <span class="pl-c1">ccdMPRPenetration</span>(obj1, obj2, &amp;ccd, &amp;depth, &amp;dir, &amp;pos);
      <span class="pl-c"><span class="pl-c">//</span> now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise</span>
      <span class="pl-c"><span class="pl-c">//</span> in depth, dir and pos is stored penetration depth, direction of</span>
      <span class="pl-c"><span class="pl-c">//</span> separation vector and position in global coordinate system</span>
  }</pre></div>
</article></div>